# A0132760M
###### src\global\Task.java
``` java
    public String getPeriodicInterval() {
        return this.periodicInterval;
    }
    
```
###### src\global\Task.java
``` java
    public String getPeriodicRepeats() {
        return this.periodicRepeats;
    }
    
```
###### src\global\Task.java
``` java
    public boolean hasPeriodicInterval() {
        if(this.periodicInterval != null) {
            return true;
        }
        return false;
    }
    
```
###### src\global\Task.java
``` java
    public boolean hasPeriodicRepeats() {
        if(this.periodicRepeats != null) {
            return true;
        }
        return false;
    }
    
```
###### src\global\Task.java
``` java
    public boolean isDone(){
        return this.isDone;
    }

```
###### src\global\Task.java
``` java
    public boolean setDone(boolean status) {
        this.isDone = status;
        return true;
    }
    
    public Task clone() {
        Task newTask = new Task();
        newTask.setName(this.getName());
        if (this.hasStartingTime()) {
            newTask.setStartingTime((Calendar) this.getStartingTime().clone());
        }
        if (this.hasEndingTime()) {
            newTask.setEndingTime((Calendar) this.getEndingTime().clone());
        }
        newTask.setLocation(this.getLocation());
        newTask.setPeriodicInterval(this.getPeriodicInterval());
        newTask.setPeriodicRepeats(this.getPeriodicRepeats());
        newTask.setDone(this.isDone());
        return newTask;
    }
    
```
###### src\logic\Logic.java
``` java
    public static void main(String[] args) {
        Logic logicObject = new Logic();
        logicObject.start();
    }

    /*
     * Constructor to initialize object variables
     */
    public Logic() {
        try {
            initializeComponentObjects();
            initializeLogFile();
            initializeConfigFile();
            updateListOfTasks();
        } catch (FileNotFoundException e) {
            UIObject.showToUser(ERROR_FILE_NOT_FOUND);
        } catch (SecurityException | IOException | NumberFormatException e) {
            UIObject.showToUser(ERROR_LOG_FILE_INITIALIZE);
        } catch (Exception e) {
            UIObject.showToUser(e.getMessage());
        }
    }

    void initializeComponentObjects() {
        UIObject = new GraphicalUI();
        parserObject = new Parser();
        storageObject = new JsonFormatStorage(true);
        historyObject = new History();
        propObject = new Properties();
    }

    /**
     * Checks if there is an existing configuration file.
     * 
     * If there is, it assumes that the config file has not been incorrectly modified
     * and reads from it
     * 
     * Else, create a config file with default settings
     * 
     * At the end of this method, the latest properties should be set
     * 
     * @throws Exception with the respective status message
     */
    void initializeConfigFile() throws Exception {
        File configFile = new File(CONFIG_FILE_NAME);
        if (configFile.exists()) {
            try {
                readConfigFile();
            } catch (IOException e) {
                throw new Exception(ERROR_READ_CONFIG_FILE);
            }
        } else {
            try {
                createAndWriteConfigFile(configFile);
            } catch (IOException e) {
                throw new Exception(ERROR_CREATE_CONFIG_FILE);
            }
        }
        setReadConfig();
    }

    /**
     * Loads the data that is stored in propObject
     * Used after reading of the configuration file
     * 
     * @throws IOException
     */
    void setReadConfig() throws IOException {
        storageObject.saveFileToPath(propObject.getProperty(PROPERTY_KEY_SAVE_FILE));
        String logLevelString = propObject.getProperty(PROPERTY_KEY_LOGGING_LEVEL);
        displaySize = Integer.parseInt(propObject.getProperty(PROPERTY_KEY_DISPLAY_SIZE));
        addAllConfigAliasToParser(); 
        switch (logLevelString) {
            case "WARNING":
                logger.setLevel(Level.WARNING);
                break;
            case "INFO":
                logger.setLevel(Level.INFO);
                break;
            case "FINE":
                logger.setLevel(Level.FINE);
                break;
            case "FINER":
                logger.setLevel(Level.FINER);
                break;
            case "FINEST":
                logger.setLevel(Level.FINEST);
                break;
            default:
                logger.setLevel(DEFAULT_LEVEL);
        }
    }

    /**
     * Creates a configuration file and writes the default values to it
     * @param configFile
     * @throws IOException
     */
    void createAndWriteConfigFile(File configFile) throws IOException {
        configFile.createNewFile();
        propObject.setProperty(PROPERTY_KEY_SAVE_FILE, DEFAULT_SAVE_FILE_PATH);
        propObject.setProperty(PROPERTY_KEY_LOGGING_LEVEL, DEFAULT_LOGGING_LEVEL_STRING);
        propObject.setProperty(PROPERTY_KEY_DISPLAY_SIZE, Integer.toString(DEFAULT_DISPLAY_SIZE));
        setAllConfigAlias();
        writeProperties();
    }

    void readConfigFile() throws FileNotFoundException, IOException {
        BufferedReader bufReader = new BufferedReader(new FileReader(
                new File(CONFIG_FILE_NAME)));
        propObject.load(bufReader);
        bufReader.close();
    }

    /**
     * Initialize the log file, and set the logger output format
     * to human-readable
     * 
     * @throws IOException
     */
    void initializeLogFile() throws IOException {
        FileHandler logHandler = new FileHandler(LOG_FILE_NAME);
        LogManager.getLogManager().reset(); // removes printout to console
                                            // aka root handler
        logHandler.setFormatter(new SimpleFormatter()); // set output to a
                                                        // human-readable
                                                        // log format
        logger.addHandler(logHandler);
    }
    
     /**
      * Sets the empty string for all the alias properties
      */
    void setAllConfigAlias(){
        for (int i = 0; i < PROPERTY_KEY_ALIAS_LIST.length; i++) {
            propObject.setProperty(PROPERTY_KEY_ALIAS_LIST[i], "");
        }
    }
    
    /**
     * Add the alias lists read from the config file to the parser
     */
    void addAllConfigAliasToParser(){
        for (int i = 0; i < listOfDefaultKeywords.length
                && i < PROPERTY_KEY_ALIAS_LIST.length; i++) {
            addConfigAlias(listOfDefaultKeywords[i],
                    propObject.getProperty(PROPERTY_KEY_ALIAS_LIST[i]));
        }
    }
    
    /**
     * Adds the new aliasString to parser's list of command keywords
     * @param existingKeyword
     * @param aliasString
     * @return true if added, false if unable to add
     */
    boolean addConfigAlias(String existingKeyword, String aliasString){
        String[] aliasWords = aliasString.split(SEPARATOR);
        boolean hasError = false;
        for (int i = 0; i < aliasWords.length; i++) {
            if (!parserObject.addAlias(existingKeyword, aliasWords[i])){
                hasError = true;
            }
        }
        return hasError;
    }

    void start() {
        initializeDisplay();
        readAndExecuteUserInput();
    }

    void initializeDisplay() {
        showUpdatedItems();
        UIObject.showStatusToUser(MESSAGE_WELCOME);
    }

    /**
     * Repeatedly Reads the user input, parses the command, executes the command
     * object, shows the result in UI, writes latest task list to file until the
     * program exits
     */
    void readAndExecuteUserInput() {
        while (true) {
            try {
                String userInput = UIObject.promptUser(MESSAGE_PROMPT_COMMAND);
                Command commandObject = parserObject.parseCommand(userInput);
                
                String executionResult = executeCommand(commandObject, true,
                        true);
                UIObject.showStatusToUser(executionResult);
                if (commandObject.getCommandType() == Command.Type.HELP && isHelpDisplayed) {
                    showHelpMessage();
                } else {
                    showUpdatedItems();
                }
                
                storageObject.writeItemList(listOfTasks);
            } catch (InterruptedException e) {
                // something interrupted the UI's wait for user input
                UIObject.showStatusToUser(ERROR_UI_INTERRUPTED);
            } catch (IOException e) {
                // error writing
                UIObject.showStatusToUser(ERROR_WRITING_FILE);
            } catch (Exception e) {
                // warning from parsing user command
                UIObject.showStatusToUser(e.getMessage());
            }
        }
    }

    /**
     * Executes a command based on commandObject
     * 
     * 
     * @param commandObject
     * @param isUserInput
     *            false if command is called from redo
     * @param isUndoHistory
     *            true if command is called from undo
     *            false if command is called by user directly
     * 
     * @return status string to be shown to user
     * @throws IOException 
     */
    String executeCommand(Command commandObject, boolean isUserInput,
            boolean isUndoHistory) {
        if (commandObject == null) {
            return ERROR_INVALID_COMMAND;
        }
        Command.Type commandType = commandObject.getCommandType();
        ArrayList<Task> userTasks = commandObject.getTasks();
        ArrayList<String> argumentList = commandObject.getArguments();
        ArrayList<Integer> indexList = new ArrayList<Integer>();
        if (commandType == null) {
            logger.warning("Command type is null!");
            return ERROR_NO_COMMAND_HANDLER;
        } else {
            switch (commandType) {
                case ADD :
                    logger.info("ADD command detected");
                    argumentList = removeDuplicates(argumentList);
                    indexList = parseIntList(argumentList);
                    // argumentList's order gets messed up after going through HashSet for size > 10
                    // So apply sort again
                    Collections.sort(indexList);
                    logger.fine("Finished processing index.");
                    return addItem(userTasks, indexList, isUserInput,
                            isUndoHistory);
                case DELETE :
                    logger.info("DELETE command detected");
                    argumentList = processIndexArguments(argumentList);
                    argumentList = removeDuplicates(argumentList);
                    if (isUserInput) {
                        try {
                            indexList = remapArguments(argumentList);
                        } catch (Exception e) {
                            return e.getMessage();
                        }
                    } else {
                        indexList = parseIntList(argumentList);
                    }
                    logger.fine("Finished processing index.");
                    return deleteItem(indexList, isUserInput, isUndoHistory);
                case EDIT :
                    logger.info("EDIT command detected");
                    argumentList = processIndexArguments(argumentList);
                    argumentList = removeDuplicates(argumentList);
                    if (isUserInput) {
                        try {
                            indexList = remapArguments(argumentList);
                        } catch (Exception e) {
                            return e.getMessage();
                        }
                    } else {
                        indexList = parseIntList(argumentList);
                    }
                    logger.fine("Finished processing index.");
                    return editItem(userTasks, indexList, isUserInput,
                            isUndoHistory);
                case DISPLAY :
                    logger.info("DISPLAY command detected");
                    return displayItems(argumentList);
                case UNDO :
                    logger.info("UNDO command detected");
                    return undoCommand();
                case REDO :
                    logger.info("REDO command detected");
                    return redoCommand();
                case SAVETO :
                    logger.info("SAVETO command detected");
                    return saveFilePath(argumentList);
                case EXIT :
                    logger.info("EXIT command detected");
                    return exitProgram();
                case MARK:
                    logger.info("MARK command detected");
                    argumentList = processIndexArguments(argumentList);
                    argumentList = removeDuplicates(argumentList);
                    if (isUserInput) {
                        try {
                            indexList = remapArguments(argumentList);
                        } catch (Exception e) {
                            return e.getMessage();
                        }
                    } else {
                        indexList = parseIntList(argumentList);
                    }
                    logger.fine("Finished processing index.");
                    return markDoneStatus(indexList, isUserInput, isUndoHistory, true);
                case UNMARK:
                    logger.info("UNMARK command detected");
                    argumentList = processIndexArguments(argumentList);
                    argumentList = removeDuplicates(argumentList);
                    if (isUserInput) {
                        try {
                            indexList = remapArguments(argumentList);
                        } catch (Exception e) {
                            return e.getMessage();
                        }
                    } else {
                        indexList = parseIntList(argumentList);
                    }
                    logger.fine("Finished processing index.");
                    return markDoneStatus(indexList, isUserInput, isUndoHistory, false);
                case SEARCH:
                    logger.info("SEARCH command detected");
                    return addSearchFilter(userTasks);
                case HELP:
                    logger.info("HELP command detected");
                    toggleHelpDisplay();
                    return MESSAGE_SUCCESS_HELP;
                case ALIAS:
                    logger.info("ALIAS command detected");
                    return addAlias(argumentList);
                default :
                    logger.warning("Command type cannot be identified!");
                    return ERROR_NO_COMMAND_HANDLER;
            }
        }
    }
    
```
###### src\logic\Logic.java
``` java
    /**
     * Concatenates the newAlias to the current property value associated with
     * the key propertyType in propObject
     * @param propertyType
     * @param newAlias
     * @return
     */
    boolean addKeywordToAliasList(String propertyType, String newAlias) {
        String curProperty = propObject.getProperty(propertyType);
        if (curProperty.equals("")) {
            propObject.setProperty(propertyType, newAlias);
        } else {
            propObject.setProperty(propertyType, curProperty + SEPARATOR
                    + newAlias);
        }
        return true;
    }
    
    
    /**
     * Attempts to add the new alias to the parser
     * 
     * If successful, it identifies the appropriate list in property object
     * to add the new alias to. Then concatenates the new alias to the list 
     * 
     * The configuration file is then written with the updated properties
     * 
     * @param argumentList
     * the first word in the list is used to identify the appropriate list
     * the second word in the list is the new alias to be added
     * @return status message
     */
    String addAlias(ArrayList<String> argumentList) {
        if (argumentList.size() < 2) {
            return ERROR_INVALID_ARGUMENT;
        }
        String commandTypeIdentifier = argumentList.get(0);
        String newAlias = argumentList.get(1);
        if (parserObject.addAlias(commandTypeIdentifier, newAlias)) {
            for (int i = 0; i < listOfDefaultKeywords.length
                    && i < PROPERTY_KEY_ALIAS_LIST.length; i++) {
                if (commandTypeIdentifier.equals(listOfDefaultKeywords[i])) {
                    addKeywordToAliasList(PROPERTY_KEY_ALIAS_LIST[i],
                            newAlias);
                }
            }
            
            try {
                writeProperties();
            } catch (IOException e) {
                return ERROR_WRITING_FILE;
            }
            return String.format(MESSAGE_SUCCESS_ALIAS, newAlias, commandTypeIdentifier);
        } else {
            return ERROR_INVALID_ARGUMENT;
        }
    }
    
    /**
     * Converts a list of integer strings into list of integers
     * 
     * @param argumentList
     * @return intList the resulting integer list
     */
    ArrayList<Integer> parseIntList(ArrayList<String> argumentList) {
        ArrayList<Integer> intList = new ArrayList<Integer>();
        for (int i = 0; i < argumentList.size(); i++) {
            intList.add(Integer.parseInt(argumentList.get(i)));
        }
        return intList;
    }
    
    /**
     * Depending on the command type, craft a status message for return
     * 
     * Pushes a reversed command to history, and returns the
     * crafted status message
     * 
     * @param commandType
     * @param commandToPush
     * @param isUserInput determines whether the undo history list should be cleared,
     * as well as the status message
     * @param isUndoHistory determines which stack the reverse command is to be pushed into
     * @return status message
     */
    String pushToHistory(Command.Type commandType, Command commandToPush, boolean isUserInput, boolean isUndoHistory) {
        String normalStatus;
        String undoStatus;
        String redoStatus;
        logger.finer("Crafting status messages.");
        switch (commandType) {
            case ADD:
                normalStatus = MESSAGE_SUCCESS_ADD;
                undoStatus = MESSAGE_UNDO + MESSAGE_SUCCESS_HISTORY_ADD;
                redoStatus = MESSAGE_REDO + MESSAGE_SUCCESS_HISTORY_ADD;
                break;
            case DELETE:
                normalStatus = MESSAGE_SUCCESS_DELETE;
                undoStatus = MESSAGE_UNDO + MESSAGE_SUCCESS_HISTORY_DELETE;
                redoStatus = MESSAGE_REDO + MESSAGE_SUCCESS_HISTORY_DELETE;
                break;
            case EDIT:
                normalStatus = MESSAGE_SUCCESS_EDIT;
                undoStatus = MESSAGE_UNDO + MESSAGE_SUCCESS_HISTORY_EDIT;
                redoStatus = MESSAGE_REDO + MESSAGE_SUCCESS_HISTORY_EDIT;
                break;
            case MARK:
                normalStatus = MESSAGE_SUCCESS_MARK;
                undoStatus = MESSAGE_UNDO + MESSAGE_SUCCESS_MARK;
                redoStatus = MESSAGE_REDO + MESSAGE_SUCCESS_MARK;
                break;
            case UNMARK:
                normalStatus = MESSAGE_SUCCESS_UNMARK;
                undoStatus = MESSAGE_UNDO + MESSAGE_SUCCESS_UNMARK;
                redoStatus = MESSAGE_REDO + MESSAGE_SUCCESS_UNMARK;
                break;
            default:
                return ERROR_HISTORY_NO_COMMAND_HANDLER;
        }
        
        logger.fine("Checking if history should be cleared.");
        if (isUserInput) {
            historyObject.clearUndoHistoryList();
        }
        logger.finer("Checking if command is called by undo.");
        if (isUndoHistory) {
            logger.finer("Command is NOT called by undo.");

            logger.finer("Attempting to reverse command and push it to history.");
            if (!historyObject.pushCommand(commandToPush, true)) {
                return ERROR_CANNOT_WRITE_TO_HISTORY;
            }
            if (isUserInput) {
                return normalStatus;
            } else {
                return redoStatus;
            }
            
        } else {
            logger.finer("Command is called by undo.");

            logger.finer("Attempting to reverse command and push it to undoHistory.");
            if (!historyObject.pushCommand(commandToPush, false)) {
                return ERROR_CANNOT_WRITE_TO_HISTORY;
            }
            return undoStatus;
        }
    }

    /**
     * Adds item(s) to the list of tasks in memory
     * 
     * Creates a reversed command with the index array of
     * the items that have been added, then pushes it to history
     * 
     * @param userTasks
     *            an arraylist of tasks to be added
     * @param indexList
     *            if empty, tasks will be added to the back of the list in the
     *            order given in userTasks else should contain the same number
     *            of elements as userTasks, to determine the positions the tasks
     *            are to be inserted at
     * @param isUserInput
     * @param isUndoHistory
     * 
     * @return status string
     */
    String addItem(ArrayList<Task> userTasks, ArrayList<Integer> indexList,
            boolean isUserInput, boolean isUndoHistory) {
        if (isEmptyTaskList(userTasks)) {
            return ERROR_INVALID_ARGUMENT;
        }
        try {
            ArrayList<Integer> parsedIntList = new ArrayList<Integer>();
            
            boolean hasClashes = false;
            logger.fine("Checking for clashes.");
            if (haveClashes(userTasks)) {
                logger.finer("Clash in timing detected.");
                hasClashes = true;
            }

            logger.fine("Adding tasks to list.");
            if (isEmptyIndexList(indexList)) {
                logger.finer("No specified index. Defaulting all items to the end of list.");
                for (int i = 0; i < userTasks.size(); i++) {
                    int index = listOfTasks.size();
                    logger.finer("Index " + (index + 1) + " generated.");
                    addHelper(userTasks, parsedIntList, i, index);
                }
            } else if (userTasks.size() != indexList.size()) {
                return ERROR_INVALID_ARGUMENT;
            } else {
                for (int i = 0; i < userTasks.size(); i++) {
                    int index = indexList.get(i);
                    logger.finer("Index " + (index + 1) + " specified.");
                    addHelper(userTasks, parsedIntList, i, index);
                }
            }

            String[] argumentListForReverse = new String[parsedIntList.size()];
            Integer[] integerArr = new Integer[parsedIntList.size()];
            parsedIntList.toArray(integerArr);
            

            logger.fine("Creating argumentList for reversed command.");
            for (int i = 0; i < parsedIntList.size(); i++) {
                argumentListForReverse[i] = String.valueOf(integerArr[i]);
            }

            String historyStatus = pushToHistory(Command.Type.ADD, new Command(
                    Command.Type.DELETE, argumentListForReverse), isUserInput,
                    isUndoHistory);
            if (hasClashes) {
                return WARNING_TIMING_CLASH;
            }
            return historyStatus;
        } catch (NumberFormatException e) {
            return ERROR_INVALID_ARGUMENT;
        } catch (Exception e) {
            return e.getMessage();
        }
    }

    /**
     * Helper for the addItem method
     * 
     * Mainly used to extract a given user task from the parser,
     * then attempts to split the task if it is recurring. At the
     * same time, it helps to keep track of the index the items are
     * added at so that the reversed command can be created
     * 
     * @param userTasks
     * @param parsedIntList index list
     * @param i the position of the relevant task & argument index
     * @param index the position in the main list the task is to be added to
     * @throws Exception
     */
    void addHelper(ArrayList<Task> userTasks,
            ArrayList<Integer> parsedIntList, int i, int index)
            throws Exception {
        Task curTask = userTasks.get(i);
        if (curTask.hasPeriodicInterval()) {
            ArrayList<Task> splitTasks = splitPeriodic(curTask);
            listOfTasks.addAll(index, splitTasks);
            for (int j = 0; j < splitTasks.size(); j++) {
                parsedIntList.add(index + j);
            }
        } else {
            listOfTasks.add(index, curTask);
            parsedIntList.add(index);
        }
    }

    /**
     * Deletes item(s) from the list of tasks in memory
     * This method will also push a reversed version of the command to history
     * 
     * @param argumentList
     *            all elements in this array should be integer strings elements
     *            the array will first have its duplicates removed, then sorted
     *            in an increasing order
     * @param isUserInput
     * @param isUndoHistory
     * 
     * @return status string
     */
    String deleteItem(ArrayList<Integer> indexList,
            boolean isUserInput, boolean isUndoHistory) {
        String[] argumentListForReverse;
        if (isEmptyIndexList(indexList)) {
            return ERROR_INVALID_ARGUMENT;
        }
        Collections.sort(indexList);

        argumentListForReverse = new String[indexList.size()];

        ArrayList<Task> tasksRemoved = new ArrayList<Task>();
        for (int i = indexList.size() - 1; i >= 0; i--) {
            int index = indexList.get(i);
            if (isValidIndex(index)) {
                argumentListForReverse[i] = Integer.toString(indexList.get(i)); // for undo

                // add to start of list to maintain order
                tasksRemoved.add(0, listOfTasks.remove(index));
                logger.fine("Task removed from list.");
            } else {
                int offset = 1;
                while (!tasksRemoved.isEmpty()) {
                    listOfTasks.add(indexList.get(i + offset),
                            tasksRemoved.remove(0));
                    offset++;
                }

                return ERROR_INVALID_INDEX;
            }

        }

        Command commandToPush = new Command(Command.Type.ADD, argumentListForReverse, tasksRemoved);
        String historyStatus = pushToHistory(Command.Type.DELETE, commandToPush, isUserInput, isUndoHistory);
        return historyStatus;
    }

    /**
     * Remaps index based on UI list to the index based on the list in memory,
     * and at the same time, converting it to integer type list
     * @param argumentList
     * @return
     * @throws Exception
     */
    ArrayList<Integer> remapArguments(
            ArrayList<String> argumentList) throws Exception {
        ArrayList<Integer> remappedArgumentList = new ArrayList<Integer>();
        for (String oldIndexString : argumentList) {
            int oldIndex;
            try {
                // if oldIndex cannot be parsed, handle exception properly 
                oldIndex = Integer.parseInt(oldIndexString) - 1;
            } catch (NumberFormatException e) {
                throw new Exception(ERROR_INVALID_ARGUMENT);
            }
            if (oldIndex < listOfShownTasks.size() && oldIndex >= 0) {
                Task task = listOfShownTasks.get(oldIndex);
                int newIndex = listOfTasks.indexOf(task);
                remappedArgumentList.add(newIndex);
            } else {
                throw new Exception(ERROR_INVALID_INDEX);
            }
        }
        return remappedArgumentList;
    }
    
    String addSearchFilter(ArrayList<Task> userTasks) {
        if (userTasks.isEmpty()) {
            return ERROR_NO_FILTER;
        } else {
            Task taskObject = userTasks.get(0);
            listFilter.add(taskObject);
            return MESSAGE_SUCCESS_SEARCH;
        }
    }
    
    /**
     * Marks a task as done or undone based on the isDone parameter
     * @param indexList
     * @param isUserInput
     * @param isUndoHistory
     * @param isDone
     * @return
     */
    String markDoneStatus(ArrayList<Integer> indexList,
            boolean isUserInput, boolean isUndoHistory, boolean isDone) {
        String[] argumentListForReverse;
        if (isEmptyIndexList(indexList)) {
            return ERROR_INVALID_ARGUMENT;
        }
        
        Collections.sort(indexList);
        argumentListForReverse = new String[indexList.size()];

        for (int i = indexList.size() - 1; i >= 0; i--) {
            int index = indexList.get(i);
            if (!isValidIndex(index)) {
                return ERROR_INVALID_INDEX;
            }
        }
        
        for (int i = indexList.size() - 1; i >= 0; i--) {
            int index = indexList.get(i);
            argumentListForReverse[i] = String.valueOf(index);

            // add to start of list to maintain order
            Task taskRemoved = listOfTasks.remove(index);
            Task cloneOfTask = taskRemoved.clone();
            cloneOfTask.setDone(isDone);
            listOfTasks.add(index, cloneOfTask);
            logger.fine("Task marked/unmarked.");
        }
        
        Command.Type commandType;
        Command.Type reversedCommandType;
        if (isDone) {
            commandType = Command.Type.MARK;
            reversedCommandType = Command.Type.UNMARK;
        } else {
            commandType = Command.Type.UNMARK;
            reversedCommandType = Command.Type.MARK;
        }
        Command commandToPush = new Command(reversedCommandType, argumentListForReverse);
        String historyStatus = pushToHistory(commandType, commandToPush, isUserInput, isUndoHistory);
        return historyStatus;
    }

```
###### src\logic\Logic.java
``` java
    /**
     * Update each of the clonedTask fields if the newTask fields
     * are not null, abiding to the restrictions of the task fields
     * e.g. there should not be a start time without an end time
     * 
     * Not that this does not support conversion of a task into recurring tasks
     * 
     * @param newTask
     * @param clonedTask
     * @return status message if there are problems, if not, null
     */
    String editFields(Task newTask, Task clonedTask) {
        if (newTask.hasName()) {
            clonedTask.setName(newTask.getName());
        }
        if (newTask.hasLocation()) {
            clonedTask.setLocation(newTask.getLocation());
        }
        if (newTask.hasStartingTime() && newTask.hasEndingTime()) {
            clonedTask.setStartingTime(newTask.getStartingTime());
            clonedTask.setEndingTime(newTask.getEndingTime());
        }
        if (newTask.hasStartingTime() && !newTask.hasEndingTime()) {
            Calendar newStartingTime = newTask.getStartingTime();
            if (!clonedTask.hasEndingTime()) {
                return ERROR_START_TIME_WITHOUT_END_TIME;
            }
            Calendar endingTime = clonedTask.getEndingTime();
            if (!newStartingTime.after(endingTime)) {
                clonedTask.setStartingTime(newTask.getStartingTime());
            } else {
                return ERROR_START_TIME_BEFORE_END_TIME;
            }
        }
        if (newTask.hasEndingTime() && !newTask.hasStartingTime()) {
            Calendar newEndingTime = newTask.getEndingTime();
            Calendar startingTime = clonedTask.getStartingTime();
            if (!newEndingTime.before(startingTime)) {
                clonedTask.setEndingTime(newTask.getEndingTime());
            } else {
                return ERROR_START_TIME_BEFORE_END_TIME;
            }
        }
        if (newTask.hasPeriodicInterval() || newTask.hasPeriodicRepeats()) {
            return ERROR_EDIT_CANNOT_RECURRING;
        }
        return null;
    }
    
    /**
     * Updates the non-null fields in the given task object to the task in memory list
     * at the given index
     * 
     * @param userTasks
     *            this should be of size 1 which contains the new task information
     *            of the relevant fields
     * @param indexList
     *            a number string, which contains the index position of the task
     *            to edit
     * @param isUserInput
     * @param isUndoHistory
     * 
     * @return status string
     */
    String editItem(ArrayList<Task> userTasks, ArrayList<Integer> indexList,
            boolean isUserInput, boolean isUndoHistory) {
        if (isEmptyIndexList(indexList) || indexList.size() != 1 || isEmptyTaskList(userTasks) || userTasks.size() != 1) {
            return ERROR_INVALID_ARGUMENT;
        }
        Task userTask = userTasks.get(0); // should only have 1 item
        try {
            logger.fine("Attempting to determine index.");
            int index = indexList.get(0);
            
            boolean hasClashes = false;
            if (isValidIndex(index)) {
                // for history
                Task taskEdited = listOfTasks.get(index);
                
                if (isUserInput) {
                    Task newTask = taskEdited.clone();
                    String statusOfSpecialEdit = editFields(userTask,
                            newTask);
                    if (statusOfSpecialEdit != null) {
                        return statusOfSpecialEdit;
                    }
                    listOfTasks.remove(index);
                    logger.fine("Old task removed from list.");
                    
                    if (hasClashes(newTask)) {
                        hasClashes = true;
                    }
                    listOfTasks.add(index, newTask);
                    logger.fine("New task added to list.");
                } else {
                    listOfTasks.remove(index);
                    logger.fine("Old task removed from list.");

                    if (hasClashes(userTask)) {
                        hasClashes = true;
                    }
                    listOfTasks.add(index, userTask);
                    logger.fine("New task added to list.");
                }
                
                String[] indexString = { Integer.toString(index) };
                String historyStatus = pushToHistory(Command.Type.EDIT, new Command(Command.Type.EDIT,
                        indexString, taskEdited), isUserInput, isUndoHistory);
                if (hasClashes) {
                    return WARNING_TIMING_CLASH;
                }
                return historyStatus;
            } else {
                return ERROR_INVALID_INDEX;
            }
        } catch (NumberFormatException e) {
            return ERROR_INVALID_ARGUMENT;
        } catch (Exception e) {
            return e.getMessage();
        }
    }

    /**
     * Based on the first argument,
     * toggles whether done & undone tasks are shown to the user,
     * as well as modify the list filter when required
     * 
     * @param argumentList
     * @return
     */
    String displayItems(ArrayList<String> argumentList) {
        if (argumentList.size() == 1 && argumentList.get(0).equals("all")) {
            shouldShowUndone = true;
            shouldShowDone = true;
            listFilter.clear();
            listFilter.add(new Task());
        } else if (argumentList.size() == 1
                && argumentList.get(0).equals("done")) {
            shouldShowUndone = false;
            shouldShowDone = true;
            listFilter.clear();
            listFilter.add(new Task());
        } else if (argumentList.size() == 1 && argumentList.get(0).equals("undone")) {
            shouldShowDone = false;
            shouldShowUndone = true;
            listFilter.clear();
            listFilter.add(new Task());
        } else {
            shouldShowUndone = true;
            shouldShowDone = true;
            listFilter.clear();
        }
        if (listOfTasks.isEmpty()) {
            return MESSAGE_DISPLAY_EMPTY;
        } else {
            return MESSAGE_SUCCESS_DISPLAY;
        }
    }

    /**
     * Sorts a list of tasks by time
     * The starting time for a task is used if it exists
     * Else the ending time for a task is used instead
     * @return
     */
    boolean sortListOfTasks() {
        Collections.sort(listOfTasks);
        return true;
    }
    
    boolean isTimingInDay(Calendar time, Calendar date) {
        return time.get(Calendar.YEAR) == date.get(Calendar.YEAR) &&
                time.get(Calendar.DAY_OF_YEAR) == date.get(Calendar.DAY_OF_YEAR);
    }
    
    /**
     * Get the list of tasks that start on the date or has a deadline on the date,
     * and add them to tasksInDay
     * @param listOfEventsDeadlines
     * @param date
     * @return
     */
    void getTasksInDay(ArrayList<Task> listOfEventsDeadlines,
            Calendar date, ArrayList<Task> tasksInDay) {
        for (int i = 0; i < listOfEventsDeadlines.size(); i++) {
            Task curTask = listOfEventsDeadlines.get(i);
            Calendar itemTime = curTask.getTime();
            if (isTimingInDay(itemTime, date)) {
                tasksInDay.add(curTask);
            }
        }
    }
    
    /**
     * This methods retrieves the help message from Storage
     * and shows it to the UI
     */
    boolean showHelpMessage() {
        UIObject.showToUser(storageObject.getHelpMessage());
        return true;
    }
    
    /**
     * This method filters the list of tasks to be shown to the user,
     * based on the current list of filter keywords
     * 
     * It will attempt to show the 3 most urgent tasks in each category of
     * floating/deadline/event by default if there are no filter keywords
     * 
     * @return calls the UI to display updated list of items
     */
    boolean showUpdatedItems() {
        listOfShownTasks.clear();
        if (listFilter.isEmpty()) {
            // default view - first closest date, second closest date, floating
            ArrayList<Task> listOfFloating = new ArrayList<Task>();
            ArrayList<Task> listOfEventsDeadlines = new ArrayList<Task>();
            
            separateFloatingTasksFromOthers(listOfFloating,
                    listOfEventsDeadlines);
            Collections.sort(listOfEventsDeadlines);
            
            ArrayList<Task> listOfFirstDate = new ArrayList<Task>();
            ArrayList<Task> listOfSecondDate = new ArrayList<Task>();
            getTasksInFirstAndSecondDate(listOfEventsDeadlines,
                    listOfFirstDate, listOfSecondDate);
            
            addTasksToList(listOfFirstDate);
            addTasksToList(listOfSecondDate);
            addTasksToList(listOfFloating);
            
            List<String> listOfTitles = new ArrayList<String>();
            addTitleForDate(listOfFirstDate, listOfTitles);
            addTitleForDate(listOfSecondDate, listOfTitles);
            addTitleForFloating(listOfFloating, listOfTitles);
            
            return UIObject.showTasks(listOfShownTasks, DisplayType.DEFAULT, listOfTitles);
        } else {
            // filtered view
            listOfShownTasks = new ArrayList<Task>();
            List<String> searchStrings = new ArrayList<String>();
            
            filterTasksByDoneUndone();
            
            searchStrings.add(FILTER_TITLE_TASK_NAME);
            searchStrings.add(FILTER_TITLE_TIME);
            searchStrings.add(FILTER_TITLE_LOCATION);
            filterTasksAndGenerateSearchStrings(searchStrings);
            
            return UIObject.showTasks(listOfShownTasks, DisplayType.FILTERED, searchStrings);
        }
    }

    /**
     * Filters tasks by done and undone depending on the
     * variable shouldShowDone & shouldShowUndone, and put
     * them into listOfShownTasks
     * 
     * If they are both true, this simply adds all tasks
     * in listOfTasks to listOfShownTasks
     */
    void filterTasksByDoneUndone() {
        for (int i = 0; i < listOfTasks.size(); i++) {
            Task curTask = listOfTasks.get(i);
            if (curTask.isDone() && shouldShowDone) {
                listOfShownTasks.add(curTask);
            }
            if (!curTask.isDone() && shouldShowUndone) {
                listOfShownTasks.add(curTask);
            }
        }
    }

    /**
     * Separates floating tasks from the rest (events and deadlines)
     * @param listOfFloating
     * @param listOfEventsDeadlines
     */
    void separateFloatingTasksFromOthers(
            ArrayList<Task> listOfFloating,
            ArrayList<Task> listOfEventsDeadlines) {
        for (int i = 0; i < listOfTasks.size(); i++) {
            Task curTask = listOfTasks.get(i);
            if (!curTask.isDone()) {
                if (curTask.hasEndingTime()) {
                    listOfEventsDeadlines.add(curTask);
                } else {
                    listOfFloating.add(curTask);
                }
            }
        }
    }

    /**
     * Fills up listOfFirstDate and listOfSecondDate using the tasks
     * in listOfEventsDeadlines that are on the closest 2 dates
     * 
     * 
     * @param listOfEventsDeadlines sorted list of tasks, according to time
     * @param listOfFirstDate
     * @param listOfSecondDate
     */
```
###### src\logic\Logic.java
``` java
    void filterTasksAndGenerateSearchStrings(List<String> searchStrings) {
        boolean isEmptyName = true;
        boolean isEmptyTime = true;
        boolean isEmptyLocation = true;
        
        // Filter by name, time, and location
        for (int j = 0; j < listFilter.size(); j++) {
            Task curFilter = listFilter.get(j);
            isEmptyName = filterByName(searchStrings, isEmptyName,
                    curFilter);
            isEmptyTime = filterByTime(searchStrings, isEmptyTime,
                    curFilter);
            isEmptyLocation = filterByLocation(searchStrings,
                    isEmptyLocation, curFilter);
        }
    }

    void addTitleForFloating(ArrayList<Task> listOfFloating,
            List<String> listOfTitles) {
        if (listOfFloating.size() != 0) {
            listOfTitles.add("Other Tasks");
        } else {
            listOfTitles.add("No Other Tasks");
        }
    }

    /**
     * Goes through the current list of shown tasks, and remove it if it
     * doesn't fit the curFilter location
     * 
     * @param searchStrings
     * @param isEmptyLocation
     * @param curFilter
     * @return isEmptyLocation updated status
     */
    boolean filterByLocation(List<String> searchStrings,
            boolean isEmptyLocation, Task curFilter) {
        String searchLocation = curFilter.getLocation();
        int i = 0;
        if (searchLocation != null) {
            if (!isEmptyLocation) {
                searchStrings.set(2,
                        searchStrings.get(2).concat(SEPARATOR));
            }
            isEmptyLocation = false;
            searchStrings.set(2, searchStrings.get(2).concat(searchLocation));
            while (i < listOfShownTasks.size()) {
                Task curTask = listOfShownTasks.get(i);
                if (curTask.getLocation() == null || !curTask.getLocation().toLowerCase().contains(searchLocation)) {
                    listOfShownTasks.remove(i);
                } else {
                    i++;
                }
            }
        }
        return isEmptyLocation;
    }

    /**
     * Goes through the current list of shown tasks, and remove it if it
     * doesn't fit the curFilter time
     * 
     * @param searchStrings
     * @param isEmptyTime
     * @param curFilter
     * @return isEmptyTime updated status
     */
    boolean filterByTime(List<String> searchStrings,
            boolean isEmptyTime, Task curFilter) {
        Calendar filterTime = curFilter.getTime();
        if (filterTime != null) {
            Calendar filterTimeStart = (Calendar) filterTime.clone();
            filterTimeStart.set(Calendar.HOUR_OF_DAY, 0);
            filterTimeStart.set(Calendar.MINUTE, 0);
            Calendar filterTimeEnd = (Calendar) filterTime.clone();
            filterTimeEnd.add(Calendar.DATE, 1);
            filterTimeEnd.set(Calendar.HOUR_OF_DAY, 0);
            filterTimeEnd.set(Calendar.MINUTE, 0);
            
            if (!isEmptyTime) {
                searchStrings.set(
                        1,
                        searchStrings.get(1).concat(
                                SEPARATOR));
            }
            isEmptyTime = false;
            searchStrings.set(
                    1,
                    searchStrings.get(1).concat(
                            dateFormat.format(filterTime.getTime())));
            int i = 0;
            while (i < listOfShownTasks.size()) {
                Task curTask = listOfShownTasks.get(i);
                if (curTask.getTime() == null
                        || curTask.getTime().before(filterTimeStart)
                        || !curTask.getTime().before(filterTimeEnd)) {
                    listOfShownTasks.remove(i);
                } else {
                    i++;
                }
            }
        }
        return isEmptyTime;
    }

    /**
     * Goes through the current list of shown tasks, and remove it if it
     * doesn't fit the curFilter name
     * 
     * @param searchStrings
     * @param isEmptyName
     * @param curFilter
     * @return isEmptyName updated status
     */
    boolean filterByName(List<String> searchStrings,
            boolean isEmptyName, Task curFilter) {
        String searchTaskName = curFilter.getName();
        int i = 0;
        if (searchTaskName != null) {
            searchTaskName = searchTaskName.toLowerCase();
            if (!isEmptyName) {
                searchStrings.set(0,
                        searchStrings.get(0).concat(SEPARATOR));
            }
            isEmptyName = false;
            searchStrings.set(0, searchStrings.get(0).concat(searchTaskName));
            while (i < listOfShownTasks.size()) {
                Task curTask = listOfShownTasks.get(i);
                if (!curTask.getName().toLowerCase().contains(searchTaskName)) {
                    listOfShownTasks.remove(i);
                } else {
                    i++;
                }
            }
        }
        return isEmptyName;
    }

    /**
     * Adds a new title to listOfTitles based on dd mm yy of
     * the first task of the listOfItemsInDate
     * 
     * @param listOfItemsInDate
     * @param listOfTitles
     */
    void addTitleForDate(ArrayList<Task> listOfItemsInDate,
            List<String> listOfTitles) {
        if (listOfItemsInDate.size() != 0) {
            Calendar curTime = Calendar.getInstance();
            int curDate = curTime.get(Calendar.DATE);
            int curMonth = curTime.get(Calendar.MONTH) + 1;
            int curYear = curTime.get(Calendar.YEAR);
            Task curItem = listOfItemsInDate.get(0);
            
            Calendar curItemTime = curItem.getTime();
            int curItemDate = curItemTime.get(Calendar.DATE);
            int curItemMonth = curItemTime.get(Calendar.MONTH) + 1;
            int curItemYear = curItemTime.get(Calendar.YEAR);
            addTitleForDateHelper(listOfTitles, curDate, curMonth, curYear,
                    curItemDate, curItemMonth, curItemYear);
        } else {
            listOfTitles.add("No Upcoming Tasks");
        }
    }

    /**
     * Generate the title based on the given the dd mm yy of the task
     * @param listOfTitles
     * @param curDate
     * @param curMonth
     * @param curYear
     * @param curItemDate
     * @param curItemMonth
     * @param curItemYear
     */
    void addTitleForDateHelper(List<String> listOfTitles, int curDate,
            int curMonth, int curYear, int curItemDate, int curItemMonth, int curItemYear) {
        Calendar itemDate = new GregorianCalendar();
        itemDate.set(Calendar.DATE, curItemDate);
        itemDate.set(Calendar.MONTH, curItemMonth - 1);
        itemDate.set(Calendar.YEAR, curItemYear);
        String itemDateString = dateFormat.format(itemDate.getTime());
        String titleTop = String.format(TITLE_TOP_DISPLAY, displaySize);
        
        boolean isSameMonthAndYear = (curMonth == curItemMonth) && (curYear == curItemYear);
        if (isSameMonthAndYear && curDate == curItemDate) {
            listOfTitles.add(titleTop + TITLE_TODAY);
        } else if (isSameMonthAndYear && curDate == curItemDate - 1) {
            listOfTitles.add(titleTop + TITLE_TOMORROW);
        } else {
            listOfTitles.add(titleTop + itemDateString);
        }
    }

    void addTasksToList(ArrayList<Task> listOfFirstDate) {
        if (listOfFirstDate.size() >= displaySize) {
            listOfShownTasks.addAll(listOfFirstDate.subList(0, displaySize));
        } else {
            listOfShownTasks.addAll(listOfFirstDate);
        }
    }

    /**
     * Retrieves the last command from history and attempts to execute it.
     * this will push the reversed version of the command to the redo history 
     * 
     * @return status message
     */
    String undoCommand() {
        Command previousCommand = historyObject.getPreviousCommand(true);
        if (previousCommand == null) {
            return ERROR_NO_HISTORY;
        }
        return executeCommand(previousCommand, false, false);
    }

    /**
     * Retrieves the last command from undo history and attempts to execute it.
     * 
     * @return status message
     */
    String redoCommand() {
        Command previousCommand = historyObject.getPreviousCommand(false);
        if (previousCommand == null) {
            return ERROR_NO_HISTORY;
        }
        return executeCommand(previousCommand, false, true);
    }

    /**
     * Sets the data file path
     * 
     * @param argumentList
     *            the file path string is read from position 0
     * @return status string
     * @throws Exception 
     */
    String saveFilePath(ArrayList<String> argumentList) {
        if (isEmptyArgumentList(argumentList)) {
            return ERROR_INVALID_ARGUMENT;
        }
        String filePath = argumentList.get(0);
        try {
            boolean locationChanged = storageObject.saveFileToPath(filePath);
            updateListOfTasks();
            if (locationChanged) {
                updateProperties(PROPERTY_KEY_SAVE_FILE, filePath);
                return MESSAGE_SUCCESS_CHANGE_FILE_PATH;
            } else {
                return MESSAGE_SUCCESS_NO_CHANGE_FILE_PATH;
            }
        } catch (IOException e) {
            return ERROR_CREATING_FILE;
        } catch (Exception e) {
            // if file is not found when updating list of task
            return e.getMessage();
        }
    }
    
    boolean isValidIndex(int index) {
        return index >= 0 && index < listOfTasks.size();
    }

    boolean isEmptyArgumentList(ArrayList<String> argumentList) {
        if (argumentList == null || argumentList.isEmpty()) {
            return true;
        }
        return false;
    }
    
    boolean isEmptyIndexList(ArrayList<Integer> indexList) {
        if (indexList == null || indexList.isEmpty()) {
            return true;
        }
        return false;
    }
    
    boolean isEmptyTaskList(ArrayList<Task> taskList) {
        if (taskList == null || taskList.isEmpty()) {
            return true;
        }
        return false;
    }

    /**
     * Checks if a list of tasks has timing clashes with other
     * tasks in memory
     * 
     * @param task
     * @return whether there is a clash or not
     */
    boolean haveClashes(ArrayList<Task> tasks) {
        for (int i = 0; i < tasks.size(); i++) {
            if (hasClashes(tasks.get(i))) {
                return true;
            }
        }
        return false;
    }

    /**
     * Checks if a given task has timing clashes with other
     * tasks in memory
     * 
     * @param task
     * @return whether there is a clash or not
     */
    boolean hasClashes(Task task) {
        if (task.getStartingTime() != null && task.getEndingTime() != null) {
            for (int i = 0; i < listOfTasks.size(); i++) {
                Task curTaskToCheck = listOfTasks.get(i);
                if (curTaskToCheck.getStartingTime() != null
                        && curTaskToCheck.getEndingTime() != null
                        && isClashing(task, curTaskToCheck)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Checks if 2 tasks are clashing
     * Note that this method expects that both tasks have
     * starting & ending times, if not the program will
     * stop execution.
     * 
     * @param taskOne
     * @param taskTwo
     * @return whether there is a clash or not
     */
    boolean isClashing(Task taskOne, Task taskTwo) {
        Calendar taskOneStart = taskOne.getStartingTime();
        Calendar taskOneEnd = taskOne.getEndingTime();
        Calendar taskTwoStart = taskTwo.getStartingTime();
        Calendar taskTwoEnd = taskTwo.getEndingTime();
        assert (!(taskOneStart == null));
        assert (!(taskOneEnd == null));
        assert (!(taskTwoStart == null));
        assert (!(taskTwoEnd == null));

        if ((taskOneStart.before(taskTwoStart) && taskOneEnd
                .before(taskTwoStart))
                || (taskTwoStart.before(taskOneStart) && taskTwoEnd
                        .before(taskOneStart))) {
            return false;
        } else {
            return true;
        }
    }

    // Create an array with all unique elements
    ArrayList<String> removeDuplicates(ArrayList<String> parsedIntArgumentList) {
        if (parsedIntArgumentList == null) {
            return new ArrayList<String>();
        }
        HashSet<String> hs = new HashSet<>();
        hs.addAll(parsedIntArgumentList);
        parsedIntArgumentList.clear();
        parsedIntArgumentList.addAll(hs);
        return parsedIntArgumentList;
    }
    
    /**
     * Reads the task list from the data file
     * @return
     * @throws Exception status message if data file cannot be found
     */
    boolean updateListOfTasks() throws Exception {
        try {
            listOfTasks = storageObject.getItemList();
        } catch (FileNotFoundException e) {
            throw new Exception(ERROR_FILE_NOT_FOUND);
        }
        return true;
    }
    
    /**
     * Creates a list of tasks with timings offset from the given
     * recurring task, then returns it
     * 
     * @param recurringTask
     * @return
     * @throws Exception
     */
    ArrayList<Task> splitPeriodic(Task recurringTask) throws Exception {
        if (!recurringTask.hasPeriodicInterval() || !recurringTask.hasPeriodicRepeats()) {
            return null; // no periodic to split
        } else {
            String noOfRepeatsString = recurringTask.getPeriodicRepeats();
            int noOfRepeats = Integer.parseInt(noOfRepeatsString);
            String periodicIntervalString = recurringTask.getPeriodicInterval();
            recurringTask.setPeriodicRepeats(null);
            recurringTask.setPeriodicInterval(null);

            ArrayList<Task> listOfRecurringTasks = new ArrayList<Task>();
            for (int i = 0; i < noOfRepeats; i++) {
                Task newTask = recurringTask.clone();
                listOfRecurringTasks.add(newTask);
                addInterval(recurringTask, periodicIntervalString);
            }
            return listOfRecurringTasks;
        }
    }
    
    /**
     * Pushes back the starting & ending time of a given task by a specified interval
     * @param curTask a task to be modified
     * @param periodicIntervalString a time interval in the form <integer> <days/weeks/months>
     * 
     */
    boolean addInterval(Task curTask, String periodicIntervalString)
            throws Exception {
        String[] periodicIntervalWords = periodicIntervalString.split(
                WHITE_SPACE_REGEX, 2);
        String periodicIntervalUnit = periodicIntervalWords[1];
        int periodicInterval;
        try {
            periodicInterval = Integer
                    .parseInt(periodicIntervalWords[0]);
        } catch (NumberFormatException e) {
            throw new Exception(ERROR_CANNOT_PARSE_PERIODIC_VALUES);
        }
        
        int calendarUnit;
        if (periodicIntervalUnit.equalsIgnoreCase("days") || periodicIntervalUnit.equalsIgnoreCase("day")) {
            calendarUnit = Calendar.DATE;
        } else if (periodicIntervalUnit.equalsIgnoreCase("weeks") || periodicIntervalUnit.equalsIgnoreCase("week")) {
            calendarUnit = Calendar.WEEK_OF_YEAR;
        } else if (periodicIntervalUnit.equalsIgnoreCase("months") || periodicIntervalUnit.equalsIgnoreCase("month")){
            calendarUnit = Calendar.MONTH;
        } else if (periodicIntervalUnit.equalsIgnoreCase("years") || periodicIntervalUnit.equalsIgnoreCase("year")){
            calendarUnit = Calendar.YEAR;
        } else {
            return false;
        }
        
        if (curTask.hasStartingTime()) {
            curTask.getStartingTime().add(calendarUnit, periodicInterval);
        }
        if (curTask.hasEndingTime()) {
            curTask.getEndingTime().add(calendarUnit, periodicInterval);
        }
        
        return true;
    }
    
    boolean updateProperties(String key, String value) throws IOException{
        propObject.setProperty(key, value);
        writeProperties();
        return true;
    }
    
    /**
     * Writes the current property keys and values to the config file
     * @return 
     * @throws IOException if there is a problem with writing to file
     */
    boolean writeProperties() throws IOException{
        BufferedWriter bufWriter = new BufferedWriter(new FileWriter(new File(CONFIG_FILE_NAME)));
        propObject.store(bufWriter, null);
        bufWriter.close();
        return true;
    }

    String exitProgram() {
        System.exit(0);
        return MESSAGE_SUCCESS_EXIT;
    }
}
```
###### src\logic\TestLogicAdd.java
``` java
    /*
     * Helper functions
     */
    public String addItem(String taskName){
        ArrayList<Task> newTasks = new ArrayList<Task>();
        newTasks.add(new Task(taskName));
        return logicObject.addItem(newTasks, new ArrayList<Integer>(), true, true);
    }
    
    public String addItem(String taskName, Calendar deadline){
        ArrayList<Task> newTasks = new ArrayList<Task>();
        Task curTask = new Task(taskName);
        curTask.setEndingTime(deadline);
        newTasks.add(curTask);
        return logicObject.addItem(newTasks, new ArrayList<Integer>(), true, true);
    }
    
    public String addItem(String taskName, Calendar startTime, Calendar endTime){
        ArrayList<Task> newTasks = new ArrayList<Task>();
        Task curTask = new Task(taskName);
        curTask.setStartingTime(startTime);
        curTask.setEndingTime(endTime);
        newTasks.add(curTask);
        return logicObject.addItem(newTasks, new ArrayList<Integer>(), true, true);
    }
    
    @Before
    public void setup(){
        File saveFile = new File("save.txt");
        saveFile.delete();
        logicObject = new Logic();
    }
    
    
    /*
     * Tests for basic addition of task with characters and numbers
     */
    @Test
    public void logicAddOne(){
        String result = addItem("item 1");
        assertEquals("Item(s) successfully added.", result);
    }
    
    /*
     * Tests for adding of tasks with weird characters
     */
    @Test
    public void logicAddTwo(){
        String result = addItem("\n\n\n %s %d !@#$%^&*()[]{}\\;',.<>/?+_-=~`");
        assertEquals("Item(s) successfully added.", result);
    }
    
    /*
     * Tests for adding of tasks that are only integers
     */
    @Test
    public void logicAddThree(){
        String result = addItem("-1");
        assertEquals("Item(s) successfully added.", result);
    }
    
    /*
     * Tests for adding of task with a deadline
     */
    @Test
    public void logicAddDeadlineOne(){
        Calendar curDate = Calendar.getInstance();
        String result = addItem("item 1", curDate);
        assertEquals("Item(s) successfully added.", result);
        assertEquals(curDate, logicObject.listOfTasks.get(0).getEndingTime());
    }
    
    /*
     * Tests for adding of event-tasks
     */
    @Test
    public void logicAddEventOne(){
        Calendar startingDate = Calendar.getInstance();
        Calendar endingDate = Calendar.getInstance();
        startingDate.set(2015, 12, 31);
        endingDate.set(2016, 1, 1);
        String result = addItem("item 1", startingDate, endingDate);
        
        assertEquals("Item(s) successfully added.", result);
        assertEquals(startingDate, logicObject.listOfTasks.get(0).getStartingTime());
        assertEquals(endingDate, logicObject.listOfTasks.get(0).getEndingTime());
    }
    
    /*
     * Tests for adding of event-tasks that have clashes
     */
    @Test
    public void logicAddEventTwo(){
        Calendar startingDate = Calendar.getInstance();
        Calendar endingDate = Calendar.getInstance();
        startingDate.set(2015, 12, 31);
        endingDate.set(2016, 1, 2);
        String result = addItem("item 1", startingDate, endingDate);
        
        Calendar startingDate2 = Calendar.getInstance();
        Calendar endingDate2 = Calendar.getInstance();
        startingDate2.set(2016,1,1);
        endingDate2.set(2016,1,2);
        
        String result2 = addItem("item 2", startingDate2, endingDate2);
        
        assertEquals(2, logicObject.listOfTasks.size());
        assertEquals("Item(s) successfully added.", result);
        assertEquals(startingDate, logicObject.listOfTasks.get(0).getStartingTime());
        assertEquals(endingDate, logicObject.listOfTasks.get(0).getEndingTime());
        assertEquals("WARNING: There are clashing timings between tasks.", result2);
        assertEquals(startingDate2, logicObject.listOfTasks.get(1).getStartingTime());
        assertEquals(endingDate2, logicObject.listOfTasks.get(1).getEndingTime());
    }
    
    @After
    public void cleanup(){
        File saveFile = new File("save.txt");
        saveFile.delete();
    }
}
```
###### src\logic\TestLogicDelete.java
``` java
    @Before
    public void setup(){
        File saveFile = new File("save1.txt");
        saveFile.delete();
        logicObject = new Logic();
    }    
    
    /*
     * Tests corner cases of erroneous deletions
     */
    @Test
    public void logicDeleteOne(){
        logicObject.listOfShownTasks = new ArrayList<Task>();
        Task task1 = new Task("item 1");
        Task task2 = new Task("item 2");
        Task task3 = new Task("item 3");
        logicObject.listOfTasks.add(task1);
        logicObject.listOfTasks.add(task2);
        logicObject.listOfTasks.add(task3);
    
        
        ArrayList<Integer> argumentList = new ArrayList<Integer>();
        String result;
        argumentList.clear();
        argumentList.add(4);
        result = logicObject.deleteItem(argumentList, true, true);
        assertEquals("Error: There is no item at this index.", result);
        
        argumentList.clear();
        argumentList.add(-1);
        result = logicObject.deleteItem(argumentList, true, true);
        assertEquals("Error: There is no item at this index.", result);
        
        argumentList.clear();
        argumentList.add(-2);
        result = logicObject.deleteItem(argumentList, true, true);
        assertEquals("Error: There is no item at this index.", result);
        
        argumentList.clear();
        argumentList.add(55);
        result = logicObject.deleteItem(argumentList, true, true);
        assertEquals("Error: There is no item at this index.", result);
        
        argumentList.clear();
        argumentList.add(2);
        result = logicObject.deleteItem(argumentList, true, true);
        assertEquals("Item(s) successfully deleted.", result);
    }
    
    /*
     * Tests multiple deletion
     */
    @Test
    public void logicDeleteMultipleOne(){
        logicObject.listOfTasks = new ArrayList<Task>();
        logicObject.listOfTasks.add(new Task("some item 1"));
        logicObject.listOfTasks.add(new Task("some item 2"));    
        logicObject.listOfTasks.add(new Task("some item 3"));
        
        ArrayList<Integer> indexList = new ArrayList<Integer>();        

        indexList.add(0);
        indexList.add(2);
        indexList.add(1);
        
        String result = logicObject.deleteItem(indexList, true, true);
        assertEquals("Item(s) successfully deleted.", result);
    }
    
    /*
     * Tests multiple deletion of a subset of tasks
     */
    @Test
    public void logicDeleteMultipleTwo(){
        logicObject.listOfTasks = new ArrayList<Task>();
        logicObject.listOfTasks.add(new Task("some item 1"));
        logicObject.listOfTasks.add(new Task("some item 2"));
        logicObject.listOfTasks.add(new Task("some item 3"));
        logicObject.listOfTasks.add(new Task("some item 4"));
        logicObject.listOfTasks.add(new Task("some item 5"));
        logicObject.listOfTasks.add(new Task("some item 6"));
        
        
        ArrayList<Integer> indexList = new ArrayList<Integer>();
        
        indexList.add(0);
        indexList.add(2);
        indexList.add(1);
        
        String result = logicObject.deleteItem(indexList, true, true);
        assertEquals("Item(s) successfully deleted.", result);
    }
    
    /*
     * Tests multiple deletion with invalid indexes
     */
    @Test
    public void logicDeleteMultipleThree(){
        logicObject.listOfTasks = new ArrayList<Task>();
        logicObject.listOfTasks.add(new Task("some item 1"));
        logicObject.listOfTasks.add(new Task("some item 2"));    
        logicObject.listOfTasks.add(new Task("some item 3"));
        logicObject.listOfTasks.add(new Task("some item 4"));
        logicObject.listOfTasks.add(new Task("some item 5"));    
        logicObject.listOfTasks.add(new Task("some item 6"));
        
        ArrayList<Integer> indexList = new ArrayList<Integer>();
        String result;
        
        indexList.add(6);
        indexList.add(22);
        indexList.add(2);
        
        result = logicObject.deleteItem(indexList, true, true);
        assertEquals("Error: There is no item at this index.", result);
        assertEquals(logicObject.listOfTasks.size(), 6);
    }
    
    /*
     * Tests multiple deletion when there are more tasks in list
     */
    @Test
    public void logicDeleteMultipleItemsSuccess() {
        logicObject.listOfTasks = new ArrayList<Task>();
        for (int i = 'a'; i <= 'z'; i++) {
            logicObject.listOfTasks.add((new Task(String.valueOf(i))));
        }
        
        ArrayList<Integer> indexList = new ArrayList<>();
        String result;
        
        indexList.add(1);
        indexList.add(2);
        indexList.add(3);
        indexList.add(4);
        indexList.add(5);
        indexList.add(24);
        indexList.add(25);
        
        result = logicObject.deleteItem(indexList, true, true);
        assertEquals("Item(s) successfully deleted.", result);
        assertEquals(logicObject.listOfTasks.size(), 19);
    }
    
    /*
     * Tests multiple deletion with invalid index
     */
    @Test
    public void logicDeleteMultipleItemsFail() {
        logicObject.listOfTasks = new ArrayList<Task>();
        for (int i = 'a'; i <= 'z'; i++) {
            logicObject.listOfTasks.add(new Task(String.valueOf(i)));
        }
        
        ArrayList<Integer> indexList = new ArrayList<>();
        String result;
        
        indexList.add(-1);
        indexList.add(2);
        indexList.add(-3);
        
        result = logicObject.deleteItem(indexList, true, true);
        assertEquals("Error: There is no item at this index.", result);
        assertEquals(logicObject.listOfTasks.size(), 26);
    }
    
    @After
    public void cleanup(){
        File saveFile = new File("save.txt");
        saveFile.delete();
    }
}
```
###### src\logic\TestLogicEdit.java
``` java
    
    @Before
    public void setup(){
        File saveFile = new File("save.txt");
        saveFile.delete();
        logicObject = new Logic();
        
        logicObject.listOfTasks.add(new Task("Item 1"));
        logicObject.listOfTasks.add(new Task("Item 2"));
        logicObject.listOfTasks.add(new Task("Item 3"));
    }
    
    /*
     * Tests corner cases of index in edit item
     */
    @Test
    public void TestEditOne(){
        ArrayList<Task> listToEdit = new ArrayList<Task>();
        ArrayList<Integer> indexList = new ArrayList<Integer>();
        String message;
        
        indexList.add(3);
        listToEdit.add(new Task("New item 99"));
        message = logicObject.editItem(listToEdit, indexList, true, true);
        assertEquals("Error: There is no item at this index.", message);
        assertEquals("Item 1", logicObject.listOfTasks.get(0).getName());
        assertEquals("Item 2", logicObject.listOfTasks.get(1).getName());
        assertEquals("Item 3", logicObject.listOfTasks.get(2).getName());
        
        indexList.clear();
        indexList.add(2);
        message = logicObject.editItem(listToEdit, indexList, true, true);
        assertEquals("Item(s) successfully edited.", message);
        assertEquals("Item 1", logicObject.listOfTasks.get(0).getName());
        assertEquals("Item 2", logicObject.listOfTasks.get(1).getName());
        assertEquals("New item 99", logicObject.listOfTasks.get(2).getName());
        
        indexList.clear();
        indexList.add(-1);
        message = logicObject.editItem(listToEdit, indexList, true, true);
        assertEquals("Error: There is no item at this index.", message);
        assertEquals("Item 1", logicObject.listOfTasks.get(0).getName());
        assertEquals("Item 2", logicObject.listOfTasks.get(1).getName());
        assertEquals("New item 99", logicObject.listOfTasks.get(2).getName());
        
        indexList.clear();
        indexList.add(-2);
        message = logicObject.editItem(listToEdit, indexList, true, true);
        assertEquals("Error: There is no item at this index.", message);
        assertEquals("Item 1", logicObject.listOfTasks.get(0).getName());
        assertEquals("Item 2", logicObject.listOfTasks.get(1).getName());
        assertEquals("New item 99", logicObject.listOfTasks.get(2).getName());
    }
    
    /*
     * Tests editing normal values multiple times
     */
    @Test
    public void TestEditTwo(){
        ArrayList<Task> listToEdit = new ArrayList<Task>();
        ArrayList<Integer> indexList = new ArrayList<Integer>();
        String message;
        
        indexList.add(0);
        listToEdit.add(new Task("New item 1"));
        message = logicObject.editItem(listToEdit, indexList, true, true);
        assertEquals("Item(s) successfully edited.", message);
        assertEquals("New item 1", logicObject.listOfTasks.get(0).getName());
        assertEquals("Item 2", logicObject.listOfTasks.get(1).getName());
        assertEquals("Item 3", logicObject.listOfTasks.get(2).getName());
        
        indexList.clear();
        listToEdit.clear();
        indexList.add(1);
        listToEdit.add(new Task("New item 2"));
        message = logicObject.editItem(listToEdit, indexList, true, true);
        assertEquals("Item(s) successfully edited.", message);
        assertEquals("New item 1", logicObject.listOfTasks.get(0).getName());
        assertEquals("New item 2", logicObject.listOfTasks.get(1).getName());
        assertEquals("Item 3", logicObject.listOfTasks.get(2).getName());
        
        indexList.clear();
        listToEdit.clear();
        indexList.add(2);
        listToEdit.add(new Task("New item 3"));
        message = logicObject.editItem(listToEdit, indexList, true, true);
        assertEquals("Item(s) successfully edited.", message);
        assertEquals("New item 1", logicObject.listOfTasks.get(0).getName());
        assertEquals("New item 2", logicObject.listOfTasks.get(1).getName());
        assertEquals("New item 3", logicObject.listOfTasks.get(2).getName());
        
        indexList.clear();
        logicObject.showUpdatedItems();
        listToEdit.clear();
        indexList.add(1);
        listToEdit.add(new Task("item 2 changed again!"));
        message = logicObject.editItem(listToEdit, indexList, true, true);
        assertEquals("Item(s) successfully edited.", message);
        assertEquals("New item 1", logicObject.listOfTasks.get(0).getName());
        assertEquals("item 2 changed again!", logicObject.listOfTasks.get(1).getName());
        assertEquals("New item 3", logicObject.listOfTasks.get(2).getName());
    }
    
    @After
    public void cleanup(){
        File saveFile = new File("save.txt");
        saveFile.delete();
    }
    
}
```
###### src\logic\TestLogicExecute.java
``` java
    Logic logicObject;
    File saveFile;
    
    public void addHelper(Task newTask){
        logicObject.listOfTasks.add(newTask);
        logicObject.listOfShownTasks.add(newTask);
    }
    
    @Before
    public void setup(){
        File saveFile = new File("save.txt");
        File anotherSaveFile = new File("anotherSave.txt");
        saveFile.delete();
        anotherSaveFile.delete();
        logicObject = new Logic();
        try {
            saveFile.createNewFile();
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        Task task_1 = new Task();
        task_1.setName("Item 1");
        Task task_2 = new Task();
        task_2.setName("Item 2");
        Task task_3 = new Task();
        task_3.setName("Item 3");
        addHelper(task_1);
        addHelper(task_2);
        addHelper(task_3);
    }
    
    @Test
    public void logicExecuteAdd(){
        Task task;
        Command commandObject;
        // case 1
        task = new Task();
        task.setName("Submit assignment");
        commandObject = new Command(Command.Type.ADD, task);
        assertEquals("Item(s) successfully added.", logicObject.executeCommand(commandObject, true, true));
        
        // case 2
        task.setName("%% Random item %%");
        commandObject = new Command(Command.Type.ADD, task);
        assertEquals("Item(s) successfully added.", logicObject.executeCommand(commandObject, true, true));
    }
    
    @Test
    public void logicExecuteDelete(){
        Command commandObject;
        String[] args;
        
        args = new String[1];
        args[0] = "2";
        commandObject = new Command(Command.Type.DELETE, args);
        assertEquals("Item(s) successfully deleted.", logicObject.executeCommand(commandObject, true, true));
        
    }
    
    @Test
    public void logicExecuteDisplay(){
        Command commandObject;
        
        // case 1
        commandObject = new Command(Command.Type.DISPLAY, new String[]{});
        assertEquals("Displaying items.", logicObject.executeCommand(commandObject, true, true));
    }
    
    @Test
    public void logicExecuteUndo(){
        Command commandObject;
        // case 1
        commandObject = new Command(Command.Type.UNDO);
        assertEquals("Error: No history found.", logicObject.executeCommand(commandObject, true, true));
    }
    
    @Test
    public void logicExecuteRedo(){
        Command commandObject;
        // case 1
        commandObject = new Command(Command.Type.REDO);
        assertEquals("Error: No history found.", logicObject.executeCommand(commandObject, true, true));
    }
    
    @Test
    public void logicExecuteSavePath(){
        Command commandObject;
        String[] args;
        
        args = new String[1];
        args[0] = "save.txt";
        commandObject = new Command(Command.Type.SAVETO, args);
        assertEquals("File path not changed. Entered file path is the same as current one used.", logicObject.executeCommand(commandObject, true, true));
        
        args = new String[1];
        args[0] = "anotherSave.txt";
        commandObject = new Command(Command.Type.SAVETO, args);
        assertEquals("File path successfully changed.", logicObject.executeCommand(commandObject, true, true));
        
        args = new String[1];
        args[0] = "save.txt";
        commandObject = new Command(Command.Type.SAVETO, args);
        assertEquals("File path successfully changed.", logicObject.executeCommand(commandObject, true, true));
    }
    
    @Test
    public void logicExecuteMark(){
        Command commandObject;
        String[] args;
        
        args = new String[1];
        args[0] = "1";
        commandObject = new Command(Command.Type.MARK, args);
        assertEquals("Item(s) successfully marked as done.", logicObject.executeCommand(commandObject, true, true));
    }
    
    @Test
    public void logicExecuteNull(){
        Command commandObject = null;
        assertEquals("Error: Invalid command.", logicObject.executeCommand(commandObject, true, true));
        
        commandObject = new Command(null, new String[]{"123"});
        assertEquals("Error: Handler for this command type has not been defined.", logicObject.executeCommand(commandObject, true, true));
        
    }
    
    @After
    public void cleanup(){
        File saveFile = new File("save.txt");
        File anotherSaveFile = new File("anotherSave.txt");
        saveFile.delete();
        anotherSaveFile.delete();
    }
}
```
###### src\logic\TestLogicHelpers.java
``` java
    @Before
    public void setup(){
        File saveFile = new File("save.txt");
        saveFile.delete();
        logicObject = new Logic();
    }
    
    /*
     * Tests clashing dates
     */
    @Test
    public void testIsClashing(){
        Calendar dateOne = new GregorianCalendar();
        dateOne.clear();
        dateOne.set(2015, 10, 9);
        Calendar dateTwo = new GregorianCalendar();
        dateTwo.clear();
        dateTwo.set(2015, 10, 13);
        Task taskOne = new Task();
        Task taskTwo = new Task();
        taskOne.setStartingTime(dateOne);
        taskOne.setEndingTime(dateTwo);
        taskTwo.setStartingTime(dateOne);
        taskTwo.setEndingTime(dateTwo);
        
        assertEquals(true, logicObject.isClashing(taskOne, taskTwo));
                
    }
    
    @After
    public void cleanup(){
        File saveFile = new File("save.txt");
        saveFile.delete();
    }
}
```
###### src\logic\TestLogicMark.java
``` java
    @Before
    public void setup(){
        File saveFile = new File("save.txt");
        saveFile.delete();
        logicObject = new Logic();
        
        logicObject.listOfTasks.add(new Task("Item 1"));
    }
    
    /**
     * Test the simplest case of marking and unmarking of a task
     */
    @Test
    public void TestMarkOne(){
        ArrayList<Integer> indexList = new ArrayList<Integer>();
        indexList.add(0);
        String result = logicObject.markDoneStatus(indexList, true, true, true);
        assertEquals(true, logicObject.listOfTasks.get(0).isDone());
        assertEquals("Item(s) successfully marked as done.", result);
        
        result = logicObject.markDoneStatus(indexList, true, true, false);
        assertEquals(false, logicObject.listOfTasks.get(0).isDone());
        assertEquals("Item(s) successfully marked as undone.", result);
    }
}
```
###### src\parser\Parser.java
``` java
    public Parser(){
        initialiseKeywordLists();
        addAllDefaultKeywords();
    }
    
    boolean initialiseKeywordLists(){
        keywordLists = new ArrayList<ArrayList<String>>();
        keywordLists.add(addKeywords);
        keywordLists.add(editKeywords);
        keywordLists.add(deleteKeywords);
        keywordLists.add(undoKeywords);
        keywordLists.add(redoKeywords);
        keywordLists.add(markKeywords);
        keywordLists.add(unmarkKeywords);
        keywordLists.add(exitKeywords);
        keywordLists.add(displayKeywords);
        keywordLists.add(searchKeywords);
        keywordLists.add(savetoKeywords);
        keywordLists.add(helpKeywords);
        keywordLists.add(aliasKeywords);
        return true;
    }
    
    boolean addAllDefaultKeywords(){
        for(int i = 0; i < COMMAND_LISTS.length && i < keywordLists.size(); i++){
            addDefaultKeywordsToList(COMMAND_LISTS[i], keywordLists.get(i));
        }
        return true;
    }
    
    boolean addDefaultKeywordsToList(String[] listOfKeywords, ArrayList<String> listInMemory){
        for (int i = 0; i < listOfKeywords.length; i++) {
            listInMemory.add(listOfKeywords[i]);
        }
        return true;
    }
    
    /**
     * Parses the command string based on keyword
     * 
     * @param command
     * @return commandObject to be executed, or null if invalid
     */
```
###### src\parser\Parser.java
``` java
    String[] getAliasArgument(String commandString) {
        return commandString.split(WHITE_SPACE_REGEX, 2);
    }
    
    String[] getSaveToArgument(String commandString) {
        return new String[] { commandString };
    }
    
    String[] getParameterOneAsArray(String commandString) {
        String indexString = commandString.split(WHITE_SPACE_REGEX, 2)[0];
        return new String[] { indexString };
    }
    
    String getParameterTwo(String commandString) {
        return commandString.split(WHITE_SPACE_REGEX)[1];
    }

    String[] getMultipleIndexes(String commandString) {
        if(commandString.length() > 0){
            String[] indexArray = commandString.split(WHITE_SPACE_REGEX);
            return indexArray;
        } else {
            return new String[0];
        }
    }

    String removeFirstWord(String commandString) {
        String[] splitCommand = commandString.split(WHITE_SPACE_REGEX, 2);
        assert (splitCommand.length >= 1);
        if (splitCommand.length == 1) {
            return "";
        } else {
            return splitCommand[1];
        }
    }
    
    /**
     * Attempts to extract field information for edit and search commands, where
     * task name is not compulsory
     * @param commandString
     * @param taskObject
     * @return
     * @throws Exception
     */
    boolean extractFieldInformation(String commandString, Task taskObject)
            throws Exception {
        logger.fine("extractFieldInformation: getting keyword markers");
        ArrayList<KeywordMarker> keywordMarkers = getArrayOfKeywordMarkers(commandString);
    
        Collections.sort(keywordMarkers);
        
        logger.fine("extractedFieldInformation: extracting data from string");
        extractName(commandString, keywordMarkers, taskObject, false);
        extractDate(commandString, keywordMarkers, taskObject, false);
        extractLocation(commandString, keywordMarkers, taskObject);
        return true;
    }

    Command.Type identifyType(String commandString) throws Exception {
        if (commandString.length() == 0) {
            logger.info("identifyType: Command string is empty!");
            throw new Exception(ERROR_EMPTY_COMMAND_STRING);
        } else {
            String firstWord = commandString.split(WHITE_SPACE_REGEX, 2)[0];
            if (isCommandKeyword(firstWord, addKeywords)) {
                return Command.Type.ADD;
            } else if (isCommandKeyword(firstWord, editKeywords)) {
                return Command.Type.EDIT;
            } else if (isCommandKeyword(firstWord, deleteKeywords)) {
                return Command.Type.DELETE;
            } else if (isCommandKeyword(firstWord, undoKeywords)) {
                return Command.Type.UNDO;
            } else if (isCommandKeyword(firstWord, redoKeywords)) {
                return Command.Type.REDO;
            } else if (isCommandKeyword(firstWord, savetoKeywords)) {
                return Command.Type.SAVETO;
            } else if (isCommandKeyword(firstWord, displayKeywords)) {
                return Command.Type.DISPLAY;
            } else if (isCommandKeyword(firstWord, exitKeywords)) {
                return Command.Type.EXIT;
            } else if (isCommandKeyword(firstWord, markKeywords)) {
                return Command.Type.MARK;
            } else if (isCommandKeyword(firstWord, unmarkKeywords)) {
                return Command.Type.UNMARK;
            } else if (isCommandKeyword(firstWord, searchKeywords)) {
                return Command.Type.SEARCH;
            } else if (isCommandKeyword(firstWord, helpKeywords)) {
                return Command.Type.HELP;
            } else if (isCommandKeyword(firstWord, aliasKeywords)) {
                return Command.Type.ALIAS;
            } else {
                logger.info("identifyType: invalid command");
                throw new Exception(ERROR_INVALID_COMMAND_SPECIFIED);
            }
        }
    }

    boolean isCommandKeyword(String firstWordInCommandString,
            String[] keywords) {
        for (int i = 0; i < keywords.length; i++) {
            if (firstWordInCommandString.equalsIgnoreCase(keywords[i])) {
                return true;
            }
        }
        return false;
    }
    
    boolean isCommandKeyword(String firstWordInCommandString,
            ArrayList<String> keywords) {
        for (int i = 0; i < keywords.size(); i++) {
            if (firstWordInCommandString.equalsIgnoreCase(keywords.get(i))) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Extracts data from the command string and puts them into the relevant field in the 
     * task object
     * @param commandString
     * @param taskObject
     * @return
     * @throws Exception
     */
    boolean extractTaskInformation(String commandString, Task taskObject)
            throws Exception {
        logger.fine("extractTaskInformation: getting keyword markers");
        ArrayList<KeywordMarker> keywordMarkers = getArrayOfKeywordMarkers(commandString);
    
        Collections.sort(keywordMarkers);
        
        logger.fine("extractedTaskInformation: extracting data from string");
        extractName(commandString, keywordMarkers, taskObject, true);
        boolean hasDate = extractDate(commandString, keywordMarkers, taskObject, true);
        extractLocation(commandString, keywordMarkers, taskObject);
        extractPeriodic(commandString, keywordMarkers, taskObject, hasDate); // valid only if date is specified
        return true;
    }
    
    boolean extractPeriodic(String commandString, ArrayList<KeywordMarker> keywordMarkers, Task taskObject, boolean hasDate) throws Exception{
        String[] periodicIntervalArguments = getArgumentsForField(commandString, keywordMarkers, FieldType.INTERVAL_PERIODIC);
        String[] periodicInstancesArguments = getArgumentsForField(commandString, keywordMarkers, FieldType.INSTANCES_PERIODIC);
        if (hasDate && periodicIntervalArguments != null
                && periodicInstancesArguments != null) {
            if (periodicIntervalArguments.length == 2) {
                logger.finer("extractPeriodic: interval argument length is 2.");
                int periodicIntervalValue;
                try {
                    periodicIntervalValue = Integer
                            .parseInt(periodicIntervalArguments[0]);
                } catch (NumberFormatException e) {
                    throw new Exception(ERROR_INVALID_PERIODIC_INTERVAL_VALUE);
                }

                String periodicIntervalUnit = periodicIntervalArguments[1];
                if (hasKeyword(periodicIntervalUnit, PERIODIC)) {
                    taskObject.setPeriodicInterval(periodicIntervalValue + " "
                            + periodicIntervalUnit);
                } else {
                    logger.info("extractPeriodic: invalid period interval");
                    throw new Exception(ERROR_INVALID_PERIODIC_INTERVAL);
                }
            } else {
                logger.info("extractPeriodic: invalid number of interval arguments - "
                        + periodicIntervalArguments.length);
                throw new Exception(ERROR_INVALID_NUMBER_OF_ARGUMENTS);
            }

            if (periodicInstancesArguments.length >= 1) {
                logger.finer("extractPeriodic: periodic argument length is 1.");
                int periodicInstancesValue;
                try {
                    periodicInstancesValue = Integer
                            .parseInt(periodicInstancesArguments[0]);
                } catch (NumberFormatException e) {
                    throw new Exception(ERROR_INVALID_PERIODIC_INSTANCES);
                }
                taskObject.setPeriodicRepeats(periodicInstancesArguments[0]);
            } else {
                logger.info("extractPeriodic: invalid number of instance arguments - "
                        + periodicInstancesArguments.length);
                throw new Exception(ERROR_INVALID_NUMBER_OF_ARGUMENTS);
            }

            return true;
        }
        return false;
    }
    
    /**
     * Extracts the location arguments as an array, joins
     * them up into a location string, and set it as the location
     * @param commandString
     * @param keywordMarkers
     * @param taskObject
     * @return
     * @throws Exception
     */
    //@@A0108355H
    boolean extractLocation(String commandString, ArrayList<KeywordMarker> keywordMarkers, Task taskObject) throws Exception{
        String[] locationArguments = getArgumentsForField(commandString, keywordMarkers, FieldType.LOCATION);
        String location = "";
        if (locationArguments != null) {
            for (int i = 0; i < locationArguments.length; i++) {
                location += locationArguments[i] + " ";
            }
            location = location.trim();
            taskObject.setLocation(location);
            logger.finer("extractLocation: location added");
            return true;
        }
        return false;
    }

```
###### src\parser\Parser.java
``` java
    private int extractMonth(String dateArgument)
            throws Exception {
        boolean integerMonth;
        int monthOne = getIndexOfList(dateArgument, Arrays.asList(MONTHS));
        
        // attempt to check if month is in integer from 1-12
        int monthTwo = -1;
        try {
            monthTwo = Integer.parseInt(dateArgument) - 1;
            integerMonth = (monthTwo >= 0 && monthTwo <= 11);
        } catch (NumberFormatException e) {
            integerMonth = false;
        }

        if (monthOne == -1 && integerMonth == false) {
            throw new Exception(ERROR_INVALID_MONTH_SPECIFIED); // not in 3-char word or int
        } else if (monthTwo != -1) {
            return monthTwo;
        } else {
            return monthOne;
        }
    }
    
    /**
     * Functions similarly to <List>.indexOf(<String>), but is not case-sensitive
     * 
     * @param word
     * @param listOfWords
     * @return index of word in list if found, else -1
     */
    private int getIndexOfList(String word, List<String> listOfWords) {
        for (int i = 0; i < listOfWords.size(); i++) {
            if (listOfWords.get(i).equalsIgnoreCase(word)) {
                return i;
            }
        }
        return -1;
    }
    

    /**
     * @param givenDayIndex day of the week sunday to saturday -> 1 to 7 
     * @return date of the nearest day
     */
    int getNearestDate(int givenDayIndex) {
        Calendar dateHelper = Calendar.getInstance();
        int curDayIndex = dateHelper.get(Calendar.DAY_OF_WEEK);
        logger.fine("getNearestDate: given day is " + givenDayIndex);
        logger.fine("getNearestDate: today is " + curDayIndex);
        int todayDate = dateHelper.get(Calendar.DATE);

        int difference = ((givenDayIndex - curDayIndex) % DAYS.length + DAYS.length)
                % DAYS.length;
        logger.fine("getNearestDate: difference is " + difference);
        int newDate = todayDate + difference;
        return newDate;
    }
    
    boolean hasKeyword(String word, String[] keywords) {
        for (int i = 0; i < keywords.length; i++) {
            if (word.equalsIgnoreCase(keywords[i])) {
                return true;
            }
        }
        return false;
    }
    
    boolean hasKeyword(String[] words, String[] keywords) {
        for (int i = 0; i < words.length; i++) {
            if (hasKeyword(words[i], keywords)) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Method created to search for TIME keywords. Can't use hasKeyword since 
     * the keyword is concatenated with the time itself, e.g. '6pm' instead of '6 pm'
     */
```
###### src\parser\Parser.java
``` java
    /**
     * Method to obtain arguments after a keyword and before the
     * next keyword
     * @param commandString
     * @param keywordMarkers
     * @param typeOfField
     * @return String array of argument words
     */
    String[] getArgumentsForField(String commandString,
            ArrayList<KeywordMarker> keywordMarkers, FieldType typeOfField) {
        for (int i = 0; i < keywordMarkers.size(); i++) {
            KeywordMarker curKeywordMarker = keywordMarkers.get(i);
            if (curKeywordMarker.getFieldType() == typeOfField) {
                int indexSearch;
                if (i < keywordMarkers.size() - 1) {
                    // get index of the next field argument
                    indexSearch = keywordMarkers.get(i + 1).getIndex() - 1;
                    logger.finer("getArgumentsForField: search starting from " + indexSearch);
                    while (commandString.charAt(indexSearch) == ' ') {
                        indexSearch--;
                    }
                    while (commandString.charAt(indexSearch) != ' ') {
                        indexSearch--;
                    }
                    while (commandString.charAt(indexSearch) == ' ') {
                        indexSearch--;
                    }
                    indexSearch++;
                } else {
                    // until the end of the string
                    indexSearch = commandString.length();
                }
                
                int curIndex = curKeywordMarker.getIndex();
                logger.finer("getArgumentsForField: curIndex is " + curIndex);
                logger.finer("getArgumentsForField: indexSearch is " + indexSearch);
                String argumentString = commandString.substring(curIndex,
                        indexSearch).replaceAll("\\\\", "");
                String[] argumentWords = argumentString.split(WHITE_SPACE_REGEX);
                return argumentWords;
            }
        }
        return null;
    }

    /**
     * Extracts task name from a string
     * It is assumed that the start of the string is the task name
     * @param commandString
     * @param keywordMarkers
     * @param taskObject
     * @return
     * @throws Exception
     */
    boolean extractName(String commandString,
            ArrayList<KeywordMarker> keywordMarkers, Task taskObject, boolean isNewTask)
            throws Exception {
        logger.fine("extractName: extracting name");
        String taskName = null;
        if (commandString.length() == 0 && isNewTask) {
            logger.info("extractName: no task information");
            throw new Exception(ERROR_EMPTY_TASK_NAME);
        } else if (keywordMarkers.size() > 0) {
            logger.finer("extractName: markersize > 0");
            int searchIndex = keywordMarkers.get(0).getIndex() - 1;
            
            logger.finer("extractName: searchIndex starts from " + searchIndex);
            while (searchIndex >= 0 && commandString.charAt(searchIndex) == ' ') {
                searchIndex--;
            }
            
            logger.finer("extractName: reached next command word at " + searchIndex);
            while (searchIndex >= 0 && commandString.charAt(searchIndex) != ' ') {
                searchIndex--;
            }
            
            logger.finer("extractName: past next command word at " + searchIndex);
            if (searchIndex >= 0) {
                taskName = commandString.substring(0, searchIndex);
            } else {
                if (isNewTask) {
                    throw new Exception(ERROR_EMPTY_TASK_NAME);
                }
            }
        } else {
            taskName = commandString;
        }
        if (taskName != null) {
            taskName = taskName.replaceAll("\\\\", "");
            taskObject.setName(taskName);
        }
        return true;
    }

    /**
     * Attempts to mark the relevant fields of a task, and adds a marker
     * to mark the starting of each field's arguments
     * 
     * @param commandString
     * @return
     * @throws Exception
     */
    ArrayList<KeywordMarker> getArrayOfKeywordMarkers (
            String commandString) throws Exception {
        ArrayList<KeywordMarker> keywordMarkerList = new ArrayList<KeywordMarker>();
        getLocationField(keywordMarkerList, commandString);
        getDateField(keywordMarkerList, commandString);
        getPeriodicField(keywordMarkerList, commandString);
        
        return keywordMarkerList;
    }
    
    /**
     * Marks indexes at which the periodic arguments are found
     * @param curMarkerList
     * @param commandString
     * @return
     * @throws Exception
     */
    boolean getPeriodicField(ArrayList<KeywordMarker> curMarkerList,
            String commandString) throws Exception {
        KeywordMarker markerForIntervalPeriodic = getKeywordMarker(commandString,
                INTERVAL_PERIODIC);
        KeywordMarker markerForInstancesPeriodic = getKeywordMarker(commandString,
                INSTANCES_PERIODIC);
        if (markerForIntervalPeriodic != null && markerForInstancesPeriodic != null) {
            markerForIntervalPeriodic.setFieldType(FieldType.INTERVAL_PERIODIC);
            curMarkerList.add(markerForIntervalPeriodic);
            markerForInstancesPeriodic.setFieldType(FieldType.INSTANCES_PERIODIC);
            curMarkerList.add(markerForInstancesPeriodic);
            return true;
        } else if (markerForIntervalPeriodic != null) {
            throw new Exception(ERROR_MISSING_REPEATS);
        } else if (markerForInstancesPeriodic != null) {
            throw new Exception(ERROR_MISSING_INTERVAL);
        } else {
            return false;
        }
    }

    /**
     * Marks indexes at which the location arguments are found
     * @param curMarkerList
     * @param commandString
     * @return
     */
    boolean getLocationField(ArrayList<KeywordMarker> curMarkerList,
            String commandString) {
        KeywordMarker markerForLocation = getKeywordMarker(commandString,
                LOCATION);
        if (markerForLocation != null) {
            markerForLocation.setFieldType(FieldType.LOCATION);
            curMarkerList.add(markerForLocation);
            return true;
        }
        return false;
    }

    /**
     * Marks indexes at which the date arguments are found
     * @param curMarkerList
     * @param commandString
     * @return
     * @throws Exception
     */
    boolean getDateField(ArrayList<KeywordMarker> curMarkerList,
            String commandString) throws Exception {
        KeywordMarker markerForDeadline = getKeywordMarker(commandString,
                DEADLINE);
        if (markerForDeadline != null) {
            markerForDeadline.setFieldType(FieldType.DEADLINE);
            curMarkerList.add(markerForDeadline);
            return true;
        }

        KeywordMarker markerForStartEvent = getKeywordMarker(commandString,
                START_EVENT);
        KeywordMarker markerForEndEvent = getKeywordMarker(commandString,
                END_EVENT);
        if (markerForStartEvent != null) {
            markerForStartEvent.setFieldType(FieldType.START_EVENT);
            curMarkerList.add(markerForStartEvent);
        }
        if (markerForEndEvent != null) {
            markerForEndEvent.setFieldType(FieldType.END_EVENT);
            curMarkerList.add(markerForEndEvent);
        }
        return true;
    }

    /**
     * Marks the index 2 positions after the found word. 
     * This index is supposed to indicate the start of the field's arguments
     * @param commandString
     * @param listOfKeywords
     * @return
     */
    KeywordMarker getKeywordMarker(String commandString,
            String[] listOfKeywords) {
        for (int i = 0; i < listOfKeywords.length; i++) {
            String curKeyword = String.format(" %s ", listOfKeywords[i]);
            String curKeywordStart = String.format("%s ", listOfKeywords[i]);
            int keywordIndex = commandString.indexOf(curKeyword);
            if (keywordIndex != -1 || commandString.startsWith(curKeywordStart)) {
                int indexOfArgument;
                if(keywordIndex != -1) {
                    indexOfArgument = keywordIndex + curKeyword.length();
                } else {
                    indexOfArgument = -1 + curKeyword.length();
                }
                int lengthOfCommandString = commandString.length();
                logger.finer("getKeywordMarker: Attempting to check " + curKeyword);
                logger.finer("getKeywordMarker: found at " + keywordIndex + " and argument is at " + indexOfArgument);
                while (lengthOfCommandString > indexOfArgument
                        && commandString.charAt(indexOfArgument) == ' ') {
                    indexOfArgument++;
                }
                KeywordMarker newMarker = new KeywordMarker();
                newMarker.setIndex(indexOfArgument);
                return newMarker;
            }
        }
        return null;
    }
    
    /**
     * Adds the new alias newCommandKeyword to the existing keyword/alias existingCommandKeyword
     * @param existingCommandKeyword
     * @param newCommandKeyword
     * @return true if added, false if cannot be added
     */
    public boolean addAlias(String existingCommandKeyword, String newCommandKeyword){
        int i = 0;
        while(i < keywordLists.size()){
            ArrayList<String> curList = keywordLists.get(i);
            if(curList.contains(existingCommandKeyword)){
                curList.add(newCommandKeyword);
                return true;
            }
            i++;
        }
        return false;
    }
}
```
