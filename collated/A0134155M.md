# A0134155M
###### Tasky/src/global/Pair.java
``` java
public class Pair<U, V> {
    private U first;
    private V second;
    
    public Pair(U first, V second) {
        this.first = first;
        this.second = second;
    }
    
    public void setFirst(U first) {
        this.first = first;
    }
    
    public void setSecond(V second) {
        this.second = second;
    }
    
    public U getFirst() {
        return first;
    }
    
    public V getSecond() {
        return second;
    }
}
```
###### Tasky/src/logic/Logic.java
``` java
    void toggleHelpDisplay() {
        isHelpDisplayed ^= true;
    }

```
###### Tasky/src/logic/Logic.java
``` java
    /**
     * Identifies special keywords in the argumentlist, and returns a
     * usable arraylist of index strings
     * @param argumentList
     * @return usable arraylist of index strings after processing
     * @throws NumberFormatException
     * @throws IndexOutOfBoundsException
     */
    ArrayList<String> processIndexArguments(ArrayList<String> argumentList)
            throws IndexOutOfBoundsException, NumberFormatException {
        try {
            ArrayList<String> finalArgumentList = new ArrayList<>();
            if (argumentList == null) {
                return null;
            }
            if (argumentList.size() == 1 && argumentList.get(0).equalsIgnoreCase(IDENTIFIER_ALL)) {
                argumentList.clear();
                for (int i = 0; i < listOfShownTasks.size(); i++) {
                    finalArgumentList.add(String.valueOf(i + 1));
                }
            } else {
                for (String argument : argumentList) {
                    if (argument.indexOf('-', 1) != -1) {
                        int dashPosition = argument.indexOf('-', 1);
                        String leftPart = argument.substring(0, dashPosition);
                        String rightPart = argument.substring(dashPosition + 1, argument.length());

                        int fromInclusive = Integer.parseInt(leftPart);
                        int toInclusive = Integer.parseInt(rightPart);
                        for (int index = fromInclusive; index <= toInclusive; index++) {
                            finalArgumentList.add(String.valueOf(index));
                        }
                    } else {
                        //unchecked
                        finalArgumentList.add(argument);
                    }
                }
            }
            return finalArgumentList;
        } catch (NumberFormatException e) {
            throw new NumberFormatException(ERROR_INVALID_ARGUMENT);
        }
    }
    
```
###### Tasky/src/storage/JsonFormatStorage.java
``` java
    /**
     * Default constructor for JsonFormatStorage. Does not use pretty formatting for JSON.
     */
    public JsonFormatStorage() {
        gson = new GsonBuilder().serializeNulls().create();
    }
    
```
###### Tasky/src/storage/JsonFormatStorage.java
``` java
    /**
     * Alternative constructor for JsonFormatStorage with option whether to prettify the
     * JSON or not.
     * @param usePrettyJson whether to format the JSON with pretty format or not
     */
    public JsonFormatStorage(boolean usePrettyJson) {
        if (usePrettyJson) {
            gson = new GsonBuilder().serializeNulls().setPrettyPrinting().create();
        } else {
            gson = new GsonBuilder().serializeNulls().create();
        }
    }
    
```
###### Tasky/src/storage/JsonFormatStorage.java
``` java
    /**
     * {@inheritDoc}
     * 
     * It saves the data in JSON format.
     */
    @Override
    public boolean writeItemList(ArrayList<Task> tasks) throws IOException {
        String jsonFormat = convertToJsonFormat(tasks);
        
        File outputFile = new File(currentFilePath);
        FileWriter outputFileWriter = new FileWriter(outputFile, false);
        
        outputFileWriter.write(jsonFormat);
        outputFileWriter.write(LINE_SEPARATOR);
        
        outputFileWriter.close();
        logger.info("JsonFormat write tasks of "+     storeInfo(tasks) + " into file: "+ currentFilePath);
        return true;
    }

```
###### Tasky/src/storage/JsonFormatStorage.java
``` java
    private String convertToJsonFormat(ArrayList<Task> tasks) {
        Task[] tasksArray = new Task[tasks.size()];
        tasksArray = tasks.toArray(tasksArray);
        
        String jsonFormat = gson.toJson(tasksArray);
        logger.info("convert to JsonFormat");
        return jsonFormat;
    }

```
###### Tasky/src/storage/JsonFormatStorage.java
``` java
    /**
     * {@inheritDoc}
     * @throws IllegalStateException if the file does not contain a valid JSON.
     */
    @Override    
    public ArrayList<Task> getItemList() throws FileNotFoundException, IllegalStateException {
        File inputFile = new File(currentFilePath);
        Scanner inputFileScanner = new Scanner(inputFile);
        
        StringBuilder rawInputData = new StringBuilder();
        while (inputFileScanner.hasNextLine()) {
            rawInputData.append(inputFileScanner.nextLine());
        }
        
        Task[] processedInputData = gson.fromJson(rawInputData.toString(), Task[].class);
        ArrayList<Task> result;
        if(processedInputData != null) {
            result = new ArrayList<>(Arrays.asList(processedInputData));
        } else {
            result = new ArrayList<>();
        }
        
        inputFileScanner.close();
        logger.info("JsonFormat get items");
        return result;
    }
    
```
###### Tasky/src/storage/Storage.java
``` java
    /**
     * Saves the list of tasks in the file
     * @param ArrayList<Task> ArrayList that stores the RAW tasks as Strings in text file
     * @return true if file is saved
     * @throws IOException 
     */
    public boolean writeItemList(ArrayList<Task> tasks) throws IOException;

```
###### Tasky/src/storage/Storage.java
``` java
    /**
     * Saves path to text file
     *
     * @param path path is a String contain the path of file to save
     * @return true if location changes
     * @throws IOException
     */
    public boolean saveFileToPath(String path) throws IOException;

```
###### Tasky/src/storage/Storage.java
``` java
    /**
     * Reads the saved file and returns the ArrayList of tasks
     * @return ArrayList of tasks read from file
     * @throws FileNotFoundException if there is no file in the filePath
     */
    public ArrayList<Task> getItemList() throws FileNotFoundException;
    
```
###### Tasky/src/ui/formatter/ColumnInfo.java
``` java
/**
 * This is a data structure that contains column name and needed width for 
 * a column.
 */
public class ColumnInfo {
    private String columnName;
    private int columnWidth;
    
    public ColumnInfo(String columnName, int columnWidth) {
        this.columnName = columnName;
        this.columnWidth = columnWidth;
    }
    
    public String getColumnName() {
        return columnName;
    }
    
    public int getColumnWidth() {
        return columnWidth;
    }
}
```
###### Tasky/src/ui/formatter/FormatterHelper.java
``` java
/**
 * This class contains several helper methods to other classes in ui.formatter package.
 */
public class FormatterHelper {
    
    private static final String EMPTY_STRING_SUBSTITUTE = " ";
    
    public static final String[] FIELD_NAMES = new String[] { "UNUSED",
            "name",
            "startingTime",
            "endingTime",
            "location",
            "isDone"
            };
    

    //TODO: automate this?
    public static final String[] TABLE_COLUMN_NAMES = new String[] { "No.",
            "Description",
            "Starting Time",
            "Ending Time",
            "Location",
            "Status"
            };
    
    public static final int COLUMN_COUNT = 6;

    private static final String TASK_DONE = "Done.";
    private static final String TASK_NOT_DONE = "Not done yet.";
    
    //additional space at the beginning and the end
    private static final int ADDITIONAL_SPACE = 2;
    
    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("dd/MM/yy h:mm a");

    /**
     * Find the minimal width for each column, taking into account the content
     * of the column and char limit for each line.
     * @param taskList
     * @param lineCharLimit
     * @return an array of ColumnInfo[] (pair of name and width) for each column.
     */
    public static ColumnInfo[] getColumnInfo(Object[][] taskListData, int lineCharLimit) {
        int[] columnLengths = new int[COLUMN_COUNT];
        
        for (int i = 0; i < columnLengths.length; i++) {
            //column length should be at least as long as the column name length
            int columnLength = TABLE_COLUMN_NAMES[i].length() + ADDITIONAL_SPACE;
            
            for (int j = 0; j < taskListData.length; j++) {
                String entry = getStringRepresentation(taskListData[j][i]);

                int currentEntryLength = entry.length();
                currentEntryLength = Math.min(currentEntryLength, lineCharLimit);
                
                columnLength  = Math.max(columnLength, currentEntryLength);
            }

            columnLengths[i] = columnLength;
        }
        
        ColumnInfo[] columnInfo = new ColumnInfo[COLUMN_COUNT];
        for (int i = 0; i < columnInfo.length; i++) {
            columnInfo[i] = new ColumnInfo(TABLE_COLUMN_NAMES[i], columnLengths[i]);
        }
        
        return columnInfo;
    }

    /**
     * Convert every field in Task class to its string representation
     * @param objectInField
     * @return string representation of <code>objectInField</code>
     */
    public static String getStringRepresentation(Object objectInField) {
        if (objectInField == null) {
            return EMPTY_STRING_SUBSTITUTE;
        }
        
        if (objectInField instanceof String) {
            return (String) objectInField;
        } else if (objectInField instanceof Calendar) {
            return String.format("%s", DATE_FORMAT.format(((Calendar) objectInField).getTime()));
        } else if (objectInField instanceof Boolean) {
            return String.format("%s", Boolean.TRUE.equals(objectInField) ? TASK_DONE
                    : TASK_NOT_DONE);
        }
        
        assert false : "Fields in Task object can only be either String, Calendar, or Boolean";
        return null;
    }

    /**
     * Split string to multiple lines according to character limit for a line as
     * specified in lineCharLimit
     * @param string
     * @param lineCharLimit
     * @return an array of string representing the content of string after split
     */
    public static String[] splitString(String string, int lineCharLimit) {
        if (string == null) {
            return new String[] {EMPTY_STRING_SUBSTITUTE};
        }
        
        List<String> resultList = new ArrayList<String>();

        int currentPosition = 0;
        while (currentPosition < string.length()) {
            if (currentPosition + lineCharLimit >= string.length()) { //we can fit all
                resultList.add(string.substring(currentPosition, string.length()));
                currentPosition = string.length();
            } else {
                int nextStartingPosition = currentPosition + lineCharLimit;
                
                String toAdd = string.substring(currentPosition, nextStartingPosition);
                resultList.add(toAdd);
                
                currentPosition = nextStartingPosition;
            }
        }
        
        String[] resultArray = resultList.toArray(new String[] {});
        
        return resultArray;
    }
    
    /**
     * Extract the data in a List<Task> to 3D object array so that it will be easier
     * to put them into a table. The first dimension of the resulting Object array
     * denotes the index of the table (since different type of tasks will be displayed
     * on a different table), the second dimension denotes the task number for each
     * table, and the last dimension denotes the fields that are in the Task data
     * structure.
     * @param tasks list of tasks to be extracted
     * @param needTaskSplit whether we need to group the tasks according to its type
     * @param minTable minimum number of table needed (empty if unused)
     * @param minRowCountPerTable minimum number of row for each table
     * @return content of <code>List<Task> tasks</code> extracted to 3D array
     */
    public static Object[][][] getTaskListData(List<Task> tasks, boolean needTaskSplit,
            int minTable, int minRowCountPerTable) {
        List<List<Task>> taskLists = new ArrayList<List<Task>>();
        if (needTaskSplit) {
            taskLists = splitTask(tasks);
        } else {
            taskLists.add(tasks);
        }

        List<Object[][]> result = new ArrayList<Object[][]>();
        //we want the numbering for all task list synchronized
        int numberCounter = 0;
        for (int taskListIndex = 0; taskListIndex < taskLists.size(); taskListIndex++) {
            List<Task> currentTaskList = taskLists.get(taskListIndex);

            //including the number column
            List<Object[]> currentTaskListData = new ArrayList<Object[]>();
            for (int i = 0; i < currentTaskList.size(); i++) {
                Task currentTask = currentTaskList.get(i);
                Object[] currentTaskData = new Object[COLUMN_COUNT];
                
                for (int j = 0; j < COLUMN_COUNT; j++) {
                    if (j == 0) {
                        currentTaskData[j] = String.valueOf(numberCounter + 1);
                        numberCounter++;
                    } else {
                        Field currentField = null;

                        try {
                            currentField = Task.class.getDeclaredField(FIELD_NAMES[j]);
                            currentField.setAccessible(true);
                            
                            Object objectInField = currentField.get(currentTask);
                            
                            currentTaskData[j] = objectInField;
                        } catch (SecurityException | NoSuchFieldException | IllegalAccessException e) {
                            assert currentField != null;
                            assert false; //should not happen
                        }
                    }
                }
                
                currentTaskListData.add(currentTaskData);
            }
            
            while (currentTaskListData.size() < minRowCountPerTable) {
                currentTaskListData.add(createEmptyTaskData());
            }
            
            result.add(currentTaskListData.toArray(new Object[1][1]));
        }
        
        while (result.size() < minTable) {
            Object[][] emptyTaskList = new Object[minRowCountPerTable][];
            
            for (int i = 0; i < minRowCountPerTable; i++) {
                emptyTaskList[i] = createEmptyTaskData();
            }
            
            result.add(emptyTaskList);
        }
        
        return result.toArray(new Object[1][1][1]);
    }

    private static Object[] createEmptyTaskData() {
        Object[] emptyTaskData = new Object[COLUMN_COUNT];

        return emptyTaskData;
    }

    private static List<List<Task>> splitTask(List<Task> tasks) {
        List<List<Task>> taskLists = new ArrayList<List<Task>>();

        for (int i = 0; i < tasks.size(); i++) {
            Task currentTask = tasks.get(i);
            Task previousTask = i == 0 ? null : tasks.get(i - 1);
            
            if (!areInSameList(currentTask, previousTask)) {
                if (currentTask.getTime() == null) {//temp workaround to display floating tasks properly (for live demo)
                    int curTaskListSize = taskLists.size();
                    for (int j = 0; j < 3 - curTaskListSize; j++) {
                        taskLists.add(new ArrayList<Task>());
                    }
                } else {
                    taskLists.add(new ArrayList<Task>());
                }
            }

            int lastTaskListIndex = taskLists.size() - 1;
            taskLists.get(lastTaskListIndex).add(currentTask);
        }

        return taskLists;
    }

    private static boolean areInSameList(Task currentTask, Task previousTask) {
        assert currentTask != null;
        if (previousTask == null) {
            return false;
        }
        if (currentTask.hasEndingTime() != previousTask.hasEndingTime()) {
            return false;
        }
        
        if (!currentTask.hasEndingTime()) {
            return true;
        } else {
            Calendar currentTaskDate = currentTask.hasStartingTime() ? currentTask.getStartingTime() :
                currentTask.getEndingTime();
            Calendar previousTaskDate = previousTask.hasStartingTime() ? previousTask.getStartingTime() :
                previousTask.getEndingTime();
            
            return areOnSameDay(currentTaskDate, previousTaskDate);
        }
    }

    private static boolean areOnSameDay(Calendar currentTaskDate, Calendar previousTaskDate) {
        return currentTaskDate.get(Calendar.YEAR) == previousTaskDate.get(Calendar.YEAR) &&
                currentTaskDate.get(Calendar.DAY_OF_YEAR) == previousTaskDate.get(Calendar.DAY_OF_YEAR);
    }
    
}
```
###### Tasky/src/ui/formatter/StringFormatter.java
``` java
/**
 * This class is used to reformat string with a particular width and / or alignment.
 */
public class StringFormatter {
    
    /* 
     * To align left a string S with a particular width W,
     * one can use : String.format("%-Ws", S); (format = "%-Ws", args = S)
     * Since W is a variable and we cannot specify W directly,
     * we create another string as a format of this String.format, using
     * another String.format
     */
    private static final String ALIGN_LEFT_ARGS_ARGS = "%%-%ds";
    
    /*
     * Similar to the above, the difference is that to align center
     * is similar to align right with some width W1 (for the string
     * and spaces on the left), and W2 (for the spaces on the right).
     * Thus, the actual String.format format that we use is :
     * String.format("%-W1s%W2s", S, "") where S is the string that
     * we want to format.
     */
    private static final String ALIGN_CENTER_ARGS_ARGS = "%%%ds%%%ds";
    
    /*
     * Similar to the ALIGN_LEFT one, but in this case, we don't need
     * the minus sign for the width.
     */
    private static final String ALIGN_RIGHT_ARGS_ARGS = "%%%ds";
    
    public static enum Alignment {
        ALIGN_LEFT, ALIGN_CENTER, ALIGN_RIGHT
    };
    
    /**
     * Format a string so that its length would be equal to <code>width</code>
     * and it will be aligned according to <code>alignment</code>
     * @param str the string to be formatted
     * @param alignment the alignment of the initial string in the resulting string.
     * @param width the final width of the resulting string.
     * @return formatted string <code>str</code> with alignment <code>alignment</code> and
     *            width </code>width</code>
     */
    public static String formatString(String str, Alignment alignment, int width) {
        assert str != null;
        assert width >= str.length() : "Width must be larger than or equal to str";
        
        String result = null;
        String stringFormatArgs;
        
        if (width >= str.length()) {
            switch (alignment) {
                case ALIGN_LEFT :
                    stringFormatArgs = String.format(ALIGN_LEFT_ARGS_ARGS, width);
                    result = String.format(stringFormatArgs, str);
                    break;
                case ALIGN_CENTER :
                    int spaceOnLeft = (width - str.length()) / 2;
                    int spaceOnRight = width - str.length() - spaceOnLeft;
                    stringFormatArgs = String.format(ALIGN_CENTER_ARGS_ARGS, spaceOnLeft + str.length(),
                                                                          spaceOnRight);
                    result = String.format(stringFormatArgs, str, "");
                    break;
                case ALIGN_RIGHT :
                    stringFormatArgs = String.format(ALIGN_RIGHT_ARGS_ARGS, width);
                    result = String.format(stringFormatArgs, str);
                    break;
                default :
                    assert false;
            }
        }
        
        assert result != null;
        return result;
    }
}
```
###### Tasky/src/ui/formatter/TableModelFormatter.java
``` java
/**
 * This class is used to convert/format an object array containing all data of a 
 * <code>Task</code> object into its string value so that it can be processed by JTable.
 */
public class TableModelFormatter {
    
    private static final String STRIKE_HTML_TAG_BEGIN = "<html><strike>";
    private static final String STRIKE_HTML_TAG_END = "</strike></html>";
    
    private static boolean USE_STRIKE_HTML_TAG = false;
    
    private static final int IS_DONE_FIELD_NUMBER = 5;
    //minus one since we do not want the last field (isDone field)
    private static final int COLUMN_COUNT = FormatterHelper.COLUMN_COUNT - 1;
    
    /**
     * Converts each field of the task in a task list data in a table produced by
     * FormatterHelper.getTaskListData() to their string representation. Also returns
     * a Boolean[] array denoting whether a task has been done or not.
     * @param taskList 2D object array denoting a task list.
     * @return Pair of 2D object array and 1D boolean array denoting formatted <code>taskList</code>
     *            and array of whether a task at that position has been done.
     */
    public Pair<Object[][], Boolean[]> formatTaskList(Object[][] taskList) {
        Object[][] tableModelData = new Object[taskList.length][COLUMN_COUNT];
        Boolean[] isDone = new Boolean[taskList.length];
        
        for (int i = 0; i < taskList.length; i++) {
            isDone[i] = (Boolean) taskList[i][IS_DONE_FIELD_NUMBER];
            
            for (int j = 0; j < COLUMN_COUNT; j++) {
                tableModelData[i][j] = FormatterHelper.getStringRepresentation(taskList[i][j]);
                
                if (isDone[i] != null && isDone[i] && USE_STRIKE_HTML_TAG) {
                    tableModelData[i][j] = STRIKE_HTML_TAG_BEGIN + tableModelData[i][j] +
                            STRIKE_HTML_TAG_END;
                }
            }
        }

        Pair<Object[][], Boolean[]> result = new Pair<Object[][], Boolean[]>(tableModelData, isDone);
        return result;
    }
    
}
```
###### Tasky/src/ui/formatter/TestStringFormatter.java
``` java
public class TestStringFormatter {

    /*
     * Test for align left, success.
     */
    @Test
    public void testLeftOk() {
        String result = StringFormatter.formatString("haha", StringFormatter.Alignment.ALIGN_LEFT,
                10);
        assertEquals("haha      ", result);
    }

    /*
     * Test for align left, fail.
     */
    @Test
    public void testLeftFail() {
        String result = StringFormatter.formatString("giraffe", StringFormatter.Alignment.ALIGN_LEFT,
                5);
        assertNull(result);
    }
    
    /*
     * Test for align center, success. Space can be distributed evenly
     * between the left part and the right part.
     */
    @Test
    public void testCenterSuccessEven() {
        String result = StringFormatter.formatString("pencil", StringFormatter.Alignment.ALIGN_CENTER,
                10);
        assertEquals(result, "  pencil  ");
    }
    
    /*
     * Test for align center, success. Space can't be distributed evenly
     * between the left part and the right part. The space on the
     * right should be 1 more than the left.
     */
    @Test
    public void testCenterSuccessNotEven() {
        String result = StringFormatter.formatString("mattress", StringFormatter.Alignment.ALIGN_CENTER,
                11);
        assertEquals(result, " mattress  ");
    }
    
    /*
     * Test for align center, fail.
     */
    @Test
    public void testCenterFail() {
        String result = StringFormatter.formatString("paper", StringFormatter.Alignment.ALIGN_CENTER,
                4);
        assertNull(result);
    }
    
    /*
     * Test for align right, success.
     */
    @Test
    public void testRightOk() {
        String result = StringFormatter.formatString("cable", StringFormatter.Alignment.ALIGN_RIGHT,
                7);
        assertEquals(result, "  cable");
    }
    
    /*
     * Test for align right, fail.
     */
    @Test
    public void testRightFail() {
        String result = StringFormatter.formatString("object long long long long", StringFormatter.Alignment.ALIGN_RIGHT,
                11);
        assertNull(result);
    }

}
```
###### Tasky/src/ui/formatter/TestTaskListFormatter.java
``` java
public class TestTaskListFormatter {

    private static final int ONE_BILLION = (int) 1e9;
    private static final String NEW_LINE = System.getProperty("line.separator");
    
    private TextFormatter formatter;
    private Calendar timeForTesting;

    @Before
    public void setup(){
        formatter = new TextFormatter();
        timeForTesting = new GregorianCalendar();
        timeForTesting.set(2020, 11, 3, 9, 0);
    }
    
    /*
     * Test formatter with infinite width available
     */
    @Test
    public void testInfiniteWidth() {
        List<Task> taskList = new ArrayList<>();
        taskList.add(new Task("Task with only description"));
        taskList.add(new Task("Task with 2 dates", timeForTesting, timeForTesting));
        
        Object[][][] taskListData = FormatterHelper.getTaskListData(taskList, false, 1, 0);

        String result = formatter.formatTaskList(taskListData, null, ONE_BILLION);
        String expected = "+-----+--------------------------+----------------+----------------+----------+-------------+" + NEW_LINE
                        + "| No. |       Description        | Starting Time  |  Ending Time   | Location |   Status    |" + NEW_LINE
                        + "+-----+--------------------------+----------------+----------------+----------+-------------+" + NEW_LINE
                        + "|1    |Task with only description|                |                |          |Not done yet.|" + NEW_LINE
                        + "+-----+--------------------------+----------------+----------------+----------+-------------+" + NEW_LINE
                        + "|2    |Task with 2 dates         |03/12/20 9:00 AM|03/12/20 9:00 AM|          |Not done yet.|" + NEW_LINE
                        + "+-----+--------------------------+----------------+----------------+----------+-------------+" + NEW_LINE
                        + NEW_LINE;
        assertEquals(expected, result);
    }
    
    /*
     * Test formatter with limited width (30 characters per line)
     */
    @Test
    public void testLimitedWidth() {
        List<Task> taskList = new ArrayList<>();
        taskList.add(new Task("Task with only description"));
        taskList.add(new Task("Task with 2 dates", timeForTesting, timeForTesting));
        taskList.add(new Task("Task with a very long long long long description with location and date",
                timeForTesting, "NUS SoC"));
        
        Object[][][] taskListData = FormatterHelper.getTaskListData(taskList, false, 1, 0);

        String result = formatter.formatTaskList(taskListData, null, 30);
        String expected = "+-----+------------------------------+----------------+----------------+----------+-------------+" + NEW_LINE
                        + "| No. |         Description          | Starting Time  |  Ending Time   | Location |   Status    |" + NEW_LINE
                        + "+-----+------------------------------+----------------+----------------+----------+-------------+" + NEW_LINE
                        + "|1    |Task with only description    |                |                |          |Not done yet.|" + NEW_LINE
                        + "+-----+------------------------------+----------------+----------------+----------+-------------+" + NEW_LINE
                        + "|2    |Task with 2 dates             |03/12/20 9:00 AM|03/12/20 9:00 AM|          |Not done yet.|" + NEW_LINE
                        + "+-----+------------------------------+----------------+----------------+----------+-------------+" + NEW_LINE
                        + "|3    |Task with a very long long lon|                |03/12/20 9:00 AM|NUS SoC   |Not done yet.|" + NEW_LINE
                        + "|     |g long description with locati|                |                |          |             |" + NEW_LINE
                        + "|     |on and date                   |                |                |          |             |" + NEW_LINE
                        + "+-----+------------------------------+----------------+----------------+----------+-------------+" + NEW_LINE
                        + NEW_LINE;
        assertEquals(expected, result);
    }
    
    @After
    public void cleanup() {
    
    }

}
```
###### Tasky/src/ui/formatter/TextFormatter.java
``` java
/**
 * This class is used to convert/format an object array containing all data of a 
 * <code>Task</code> object into its string value and put them into a table made from 
 * <i>ASCII</i> characters.
 */
public class TextFormatter {

    private static final String NULL_STRING_SUBSTITUTE = "";
    
    private static final String MESSAGE_DISPLAY_NEWLINE = System.getProperty("line.separator");
    private static final String MESSAGE_DISPLAY_EMPTY = "No items to display.";
    
    private static final char INTERSECTION_CHAR = '+';
    private static final char HORIZONTAL_CHAR = '-';
    private static final char VERTICAL_CHAR = '|';
    
    /**
     * Format a given list of 3D Object array containing task data into a string table.
     * @param taskLists
     * @param lineCharLimit
     * @return string table containing all tasks data
     */
    public String formatTaskList(Object[][][] taskLists, List<String> tableTitles, int lineCharLimit) {
        if (isEmpty(taskLists)) {
            return MESSAGE_DISPLAY_EMPTY;
        }

        StringBuilder result = new StringBuilder();
        for (int taskListIndex = 0; taskListIndex < taskLists.length; taskListIndex++) {
            Object[][] taskList = taskLists[taskListIndex];
            ColumnInfo[] columnInfo = FormatterHelper.getColumnInfo(taskList, lineCharLimit);
            
            if (isValidIndex(tableTitles, taskListIndex)) {
                String currentTableTitle = tableTitles.get(taskListIndex);
                result.append(currentTableTitle);
                result.append(MESSAGE_DISPLAY_NEWLINE);
            }
            
            result.append(getRowSeparator(columnInfo));
            result.append(getHeader(columnInfo));
            for (int i = 0; i < taskList.length; i++) {
                Object[] currentTaskInfo = taskList[i];
                
                result.append(getRowSeparator(columnInfo));
                result.append(getTaskData(columnInfo, currentTaskInfo, i, lineCharLimit));
            }
            result.append(getRowSeparator(columnInfo));
            result.append(MESSAGE_DISPLAY_NEWLINE);
        }
        
        return result.toString();
    }

    private boolean isValidIndex(List<String> tableTitles, int taskListIndex) {
        if (tableTitles == null) {
            return false;
        } else {
            return 0 <= taskListIndex && taskListIndex < tableTitles.size();
        }
    }

    private boolean isEmpty(Object[][][] taskLists) {
        int maxLength = 0;
        for (Object[][] taskList : taskLists) {
            if (taskList != null) {
                maxLength = Math.max(maxLength, taskList.length);
            }
        }
        return maxLength == 0;
    }

    private String getTaskData(ColumnInfo[] columnInfo, Object[] task, int taskId, int lineCharLimit) {
        StringBuilder result = new StringBuilder();
        
        String[][] columnData = new String[columnInfo.length][];
        
        for (int i = 0; i < columnInfo.length; i++) {
            String stringRepresentation = FormatterHelper.getStringRepresentation(task[i]);
            columnData[i] = FormatterHelper.splitString(stringRepresentation, lineCharLimit);
        }
        
        int rowCountForCurrentTask = 0;
        for (int i = 0; i < columnData.length; i++) {
            rowCountForCurrentTask = Math.max(rowCountForCurrentTask, columnData[i].length);
        }
        
        for (int row = 1; row <= rowCountForCurrentTask; row++) {
            result.append(VERTICAL_CHAR);
            for (int i = 0; i < columnData.length; i++) {
                if (columnData[i].length >= row) {
                    result.append(StringFormatter.formatString(columnData[i][row - 1],
                            StringFormatter.Alignment.ALIGN_LEFT,
                            columnInfo[i].getColumnWidth()));
                    result.append(VERTICAL_CHAR);
                } else {
                    result.append(StringFormatter.formatString(NULL_STRING_SUBSTITUTE, 
                            StringFormatter.Alignment.ALIGN_LEFT,
                            columnInfo[i].getColumnWidth()));
                    result.append(VERTICAL_CHAR);
                }
            }
            result.append(MESSAGE_DISPLAY_NEWLINE);
        }
        
        return result.toString();
    }

    private String getHeader(ColumnInfo[] columnInfo) {
        StringBuilder result = new StringBuilder();
        
        result.append(VERTICAL_CHAR);
        for (int i = 0; i < columnInfo.length; i++) {
            result.append(StringFormatter.formatString(columnInfo[i].getColumnName(), 
                    StringFormatter.Alignment.ALIGN_CENTER,
                    columnInfo[i].getColumnWidth()));
            result.append(VERTICAL_CHAR);
        }
        result.append(MESSAGE_DISPLAY_NEWLINE);
        
        return result.toString();
    }

    private String getRowSeparator(ColumnInfo[] columnInfo) {
        StringBuilder result = new StringBuilder();
        
        result.append(INTERSECTION_CHAR);
        for (int i = 0; i < columnInfo.length; i++) {
            for (int j = 0; j < columnInfo[i].getColumnWidth(); j++) {
                result.append(HORIZONTAL_CHAR);
            }
            result.append(INTERSECTION_CHAR);
        }
        result.append(MESSAGE_DISPLAY_NEWLINE);
        
        return result.toString();
    }
    
}
```
###### Tasky/src/ui/GraphicalUI.java
``` java
/**
 * This class implements UI. This class mainly uses <code>Swing</code> to display data to and 
 * interact with the user.
 */
public class GraphicalUI implements UI {
    
    /*
     * Roughly, the UI can be modeled as the following grid :
     * 
     * +---+---+---+
     * | 1 | 2 | 3 |
     * +---+---+---+
     * | 4 | 5 | 6 |
     * +---+---+---+
     * | 7 | 8 | 9 |
     * +---+---+---+
     * 
     * where :
     *  > displayArea occupies cell 1-3
     *  > statusBar occupies cell 4-6
     *  > promptLabel occupies cell 7
     *  > userInputField occupies cell 8-9
     */
    
    /*
     * Declaration of variables
     */
    private Logger logger = Logger.getGlobal();
    
    private static final int DEFAULT_WIDTH = 850;
    private static final int DEFAULT_HEIGHT = 480;
    private static final int USER_INPUT_FIELD_CHAR_COUNT = 50;
    private static final int PROMPT_LABEL_CHAR_COUNT = 10;
    
    private static final int DISPLAY_AREA_POS_Y = 0;
    private static final int DISPLAY_AREA_POS_X = 0;
    private static final int DISPLAY_AREA_LEN_Y = 1;
    private static final int DISPLAY_AREA_LEN_X = 3;
    
    private static final int PROMPT_LABEL_POS_Y = 2;
    private static final int PROMPT_LABEL_POS_X = 0;
    private static final int PROMPT_LABEL_LEN_Y = 1;
    private static final int PROMPT_LABEL_LEN_X = 1;
    
    private static final int USER_INPUT_FIELD_POS_Y = 2;
    private static final int USER_INPUT_FIELD_POS_X = 1;
    private static final int USER_INPUT_FIELD_LEN_Y = 1;
    private static final int USER_INPUT_FIELD_LEN_X = 2;
    
    private static final int STATUS_BAR_POS_Y = 1;
    private static final int STATUS_BAR_POS_X = 0;
    private static final int STATUS_BAR_LEN_Y = 1;
    private static final int STATUS_BAR_LEN_X = 3;
    
    private static final int INVISIBLE_JPANEL_WIDTH = 100;
    private static final int INVISIBLE_JPANEL_HEIGHT = 20;
    
    private static final String FRAME_TITLE = "Tasky";
    private static final String DISPLAY_AREA_FONT_NAME = "Lucida Console";
    private static final int DISPLAY_AREA_FONT_STYLE = Font.PLAIN;
    private static final int DISPLAY_AREA_FONT_SIZE = 12;
    
    private static final Color THEME_COLOR = new Color(0x443266);
    
    private static final String EMPTY_STRING = "";
    
    private static final int SCROLL_SPEED = 10;
    
    /*
     * Initialization of GUI variables
     */
    private JFrame frame = new JFrame(FRAME_TITLE);
    private JPanel displayAreaPanel = new JPanel();
    private JScrollPane displayAreaScrollPane = new JScrollPane(displayAreaPanel);
    private JLabel promptLabel = new JLabel(DEFAULT_PROMPT, PROMPT_LABEL_CHAR_COUNT);
    private JTextField userInputField = new JTextField(USER_INPUT_FIELD_CHAR_COUNT);
    private StatusBar statusBar = new StatusBar();
    
    private UserInputHistory userInputHistory = new UserInputHistory();
    
    private boolean isTableTitleVisible = true;

    /*
     * Constructor
     */
    public GraphicalUI() {
        prepareComponents();
        addComponentsToPane(frame.getContentPane());
        displayFrame();
    }
    
    private void addComponentsToPane(Container contentPane) {
        addDisplayAreaScrollPane(contentPane);
        addPromptLabel(contentPane);
        addUserInputField(contentPane);
        addStatusBar(contentPane);
    }

    private void addStatusBar(Container contentPane) {
        GridBagConstraints constraint = new GridBagConstraints();
        
        constraint.fill = GridBagConstraints.HORIZONTAL;
        constraint.gridx = STATUS_BAR_POS_X;
        constraint.gridy = STATUS_BAR_POS_Y;
        constraint.gridheight = STATUS_BAR_LEN_Y;
        constraint.gridwidth = STATUS_BAR_LEN_X;
        
        logger.log(Level.CONFIG, String.format("%s: fill = %s, gridx = %d, gridy = %d, "
                + "gridheight = %d, gridwidth = %d", "STATUS_BAR", "GridBagConstraints.HORIZONTAL",
                STATUS_BAR_POS_X, STATUS_BAR_POS_Y, STATUS_BAR_LEN_Y, STATUS_BAR_LEN_X));
        statusBar.setBorder(new RoundedBorder(THEME_COLOR, 10));
        contentPane.add(statusBar, constraint);
    }

    private void addUserInputField(Container contentPane) {
        GridBagConstraints constraint = new GridBagConstraints();
        
        constraint.fill = GridBagConstraints.HORIZONTAL;
        constraint.gridx = USER_INPUT_FIELD_POS_X;
        constraint.gridy = 2;
        constraint.gridwidth = USER_INPUT_FIELD_LEN_X;
        
        logger.log(Level.CONFIG, String.format("%s: fill = %s, gridx = %d, gridy = %d, "
                + "gridheight = %d, gridwidth = %d", "USER_INPUT_FIELD", "GridBagConstraints.HORIZONTAL",
                USER_INPUT_FIELD_POS_X, USER_INPUT_FIELD_POS_Y,
                USER_INPUT_FIELD_LEN_Y, USER_INPUT_FIELD_LEN_X));
        userInputField.setForeground(Color.BLACK);
        userInputField.setBorder(new RoundedBorder(THEME_COLOR, 10));
        
        contentPane.add(userInputField, constraint);
    }

    private void addPromptLabel(Container contentPane) {
        GridBagConstraints constraint = new GridBagConstraints();
        
        constraint.fill = GridBagConstraints.HORIZONTAL;
        constraint.gridx = PROMPT_LABEL_POS_X;
        constraint.gridy = PROMPT_LABEL_POS_Y;
        constraint.gridheight = PROMPT_LABEL_LEN_Y;
        constraint.gridwidth = PROMPT_LABEL_LEN_X;
        
        logger.log(Level.CONFIG, String.format("%s: fill = %s, gridx = %d, gridy = %d, "
                + "gridheight = %d, gridwidth = %d", "PROMPT_LABEL", "GridBagConstraints.HORIZONTAL",
                PROMPT_LABEL_POS_X, PROMPT_LABEL_POS_Y, PROMPT_LABEL_LEN_Y, PROMPT_LABEL_LEN_X));
        promptLabel.setForeground(THEME_COLOR);
        
        contentPane.add(promptLabel, constraint);
    }

    private void addDisplayAreaScrollPane(Container contentPane) {
        GridBagConstraints constraint = new GridBagConstraints();
        constraint.fill = GridBagConstraints.BOTH;
        constraint.gridx = DISPLAY_AREA_POS_X;
        constraint.gridy = DISPLAY_AREA_POS_Y;
        constraint.gridheight = DISPLAY_AREA_LEN_Y;
        constraint.gridwidth = DISPLAY_AREA_LEN_X;
        constraint.weightx = 1.0;
        constraint.weighty = 1.0;
        
        logger.log(Level.CONFIG, String.format("%s: fill = %s, gridx = %d, gridy = %d, "
                + "gridheight = %d, gridwidth = %d, weightx = %.2f, weighty = %.2f",
                "DISPLAY_AREA", "GridBagConstraints.HORIZONTAL",
                STATUS_BAR_POS_X, STATUS_BAR_POS_Y, STATUS_BAR_LEN_Y, STATUS_BAR_LEN_X, 1.0, 1.0));
        
        contentPane.add(displayAreaScrollPane, constraint);
    }

    private void displayFrame() {
        frame.pack();
        frame.setLocationRelativeTo(null);
        frame.setVisible(true);
    }

    private void prepareComponents() {
        prepareFrame();
        prepareUserInput();
        prepareDisplayAreaPanel();
        prepareDisplayAreaScrollPane();
        preparePromptLabel();
    }
    
    private void preparePromptLabel() {
        promptLabel.setHorizontalAlignment(SwingConstants.CENTER);
    }

    private void prepareDisplayAreaScrollPane() {
        displayAreaScrollPane.setPreferredSize(new Dimension(DEFAULT_WIDTH, DEFAULT_HEIGHT));
    }
    
    private void prepareDisplayAreaPanel() {
        displayAreaPanel.setLayout(new VerticalLayout());
        displayAreaPanel.setBackground(Color.WHITE);
        displayAreaPanel.setBorder(new RoundedBorder(THEME_COLOR, 10));
    }

    private void prepareUserInput() {
        userInputField.setEditable(false);
        userInputField.setColumns(USER_INPUT_FIELD_CHAR_COUNT);
        
        userInputField.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                synchronized (userInputField) {
                    userInputField.notify();
                }
            }
        });
        
        /*
         * Clears userInputField when "esc" is pressed
         */
        @SuppressWarnings("serial")
        Action clearText = new AbstractAction() {
            public void actionPerformed(ActionEvent e) {
                userInputField.setText("");
            }
        };
        userInputField.getInputMap().put(KeyStroke.getKeyStroke("ESCAPE"), clearText);
        
        
        @SuppressWarnings("serial")
        Action lastText = new AbstractAction() {
            public void actionPerformed(ActionEvent e) {
                String userInputFromHistory = userInputHistory.moveUpInHistory();
                userInputField.setText(userInputFromHistory);
            }
        };
        userInputField.getInputMap().put(KeyStroke.getKeyStroke("UP"), lastText);
        
        @SuppressWarnings("serial")
        Action nextText = new AbstractAction() {
            public void actionPerformed(ActionEvent e) {
                String userInputFromHistory = userInputHistory.moveDownInHistory();
                userInputField.setText(userInputFromHistory);
            }
        };
        userInputField.getInputMap().put(KeyStroke.getKeyStroke("DOWN"), nextText);
        
        @SuppressWarnings("serial")
        Action scrollDown = new AbstractAction() {
            public void actionPerformed(ActionEvent e) {
                JViewport viewPort = displayAreaScrollPane.getViewport();
                Point position = viewPort.getViewPosition();
                movePosition(viewPort, position, 0, SCROLL_SPEED);
                viewPort.setViewPosition(position);
            }
        };
        userInputField.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_PAGE_DOWN, 0), scrollDown);
        
        @SuppressWarnings("serial")
        Action scrollUp = new AbstractAction() {
            public void actionPerformed(ActionEvent e) {
                JViewport viewPort = displayAreaScrollPane.getViewport();
                Point position = viewPort.getViewPosition();
                movePosition(viewPort, position, 0, -SCROLL_SPEED);
                viewPort.setViewPosition(position);
            }
        };
        userInputField.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_PAGE_UP, 0), scrollUp);
        
        @SuppressWarnings("serial")
        Action toggleHeaderVisibility = new AbstractAction() {
            public void actionPerformed(ActionEvent e) {
                isTableTitleVisible ^= true;
                redrawDisplayAreaPanel();
            }
        };
        userInputField.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_F2, 0), 
                toggleHeaderVisibility);
        
        @SuppressWarnings("serial")
        Action displayHelp = new AbstractAction() {
            public void actionPerformed(ActionEvent e) {
                userInputField.setText("help");
                synchronized (userInputField) {
                    userInputField.notify();
                }
            }
        };
        userInputField.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_F1, 0), displayHelp);
    }
    
    private void redrawDisplayAreaPanel() {
        Component[] currentComponents = displayAreaPanel.getComponents();
        
        for (Component component : currentComponents) {
            if (component instanceof JLabel) {
                component.setVisible(isTableTitleVisible);
            }
        }
        
        displayAreaPanel.revalidate();
        displayAreaPanel.repaint();
    }
    
    private void movePosition(JViewport viewPort, Point position, int dx, int dy) {
        position.x += dx;
        position.y += dy;
        
        position.x = Math.max(position.x, 0);
        position.x = Math.min(position.x, getViewPortMaxX(viewPort));
        
        position.y = Math.max(position.y, 0);
        position.y = Math.min(position.y, getViewPortMaxY(viewPort));
    }
    
    private int getViewPortMaxX(JViewport viewPort) {
        return viewPort.getView().getWidth() - viewPort.getWidth();
    }
    
    private int getViewPortMaxY(JViewport viewPort) {
        return viewPort.getView().getHeight() - viewPort.getHeight();
    }

    private void prepareFrame() {
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.getContentPane().setLayout(new GridBagLayout());
        
        /*
         * Focus given to userInputField when window is activated
         */
        frame.addWindowListener(new WindowAdapter() {
            public void windowActivated(WindowEvent e) {
                userInputField.grabFocus();
            }
        });
    }

    @Override
    public String promptUser(String prompt) {
        logger.info("Entering promptUser(prompt = " + prompt + ")");
        
        prepareComponentForUserInput(prompt);
        waitForUserInput();
        sanitizeUserInput();
        
        String userInput = getUserInput();
        
        userInputHistory.addToHistory(userInput);
        cleanUserInputField();
        
        logger.info("Returning from promptUser");
        
        return userInput;
    }

    private void cleanUserInputField() {
        userInputField.setText(EMPTY_STRING);
    }

    private String getUserInput() {
        return userInputField.getText();
    }
    
    private void sanitizeUserInput() {
        String userInput = userInputField.getText();
        userInput = userInput.replaceAll("\t", " ");
        userInputField.setText(userInput);
    }

    private void prepareComponentForUserInput(String prompt) {
        promptLabel.setText(prompt);
        userInputField.setEditable(true);
        userInputField.grabFocus();
    }

    private void waitForUserInput() {
        userInputField.getCaret().setVisible(true);
        try {
            synchronized (userInputField) {
                while (userInputField.getText().isEmpty()) {
                    userInputField.wait();
                }
            }
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
    
    @Override
    public boolean showToUser(String stringToShow) {
        JTextArea textArea = createJTextAreaWithMonospaceFont();
        textArea.setText(stringToShow);

        displayAreaPanel.removeAll();
        displayAreaPanel.add(textArea);
        displayAreaPanel.revalidate();
        displayAreaPanel.repaint();

        return true;
    }
    
    private boolean showToUserFilteredTable(TaskTableModel[] tableModels, List<String> filters) {
        displayAreaPanel.removeAll();

        VerticalLayout displayAreaPanelLayout = (VerticalLayout) displayAreaPanel.getLayout();
        displayAreaPanelLayout.resetLayout();
    
    
        for (String filter : filters) {
            JLabel label = new JLabel(filter);
            displayAreaPanel.add(label);
        }
        
        for (int i = 0; i < tableModels.length; i++) {
            TaskTable currentTable = new TaskTable(tableModels[i]);
            currentTable.setFocusable(false);
            currentTable.setRowSelectionAllowed(false);
            
            displayAreaPanel.add(currentTable.getTableHeader());
            displayAreaPanel.add(currentTable);
            displayAreaPanel.add(createInvisibleJPanel(INVISIBLE_JPANEL_WIDTH,
                    INVISIBLE_JPANEL_HEIGHT));
        }

        displayAreaPanel.revalidate();
        displayAreaPanel.repaint();

        return true;
    }
    
    
    private boolean showToUserDefaultTable(TaskTableModel[] tableModels, List<String> titles) {

        assert tableModels.length <= titles.size();
        displayAreaPanel.removeAll();

        VerticalLayout displayAreaPanelLayout = (VerticalLayout) displayAreaPanel.getLayout();
        displayAreaPanelLayout.resetLayout();
        
        TableColumnModel commonColumnModel = null;
        
        for (int i = 0; i < tableModels.length; i++) {
            TaskTable currentTable = null;

            if (commonColumnModel == null) {
                currentTable = new TaskTable(tableModels[i]);
            } else {
                currentTable = new TaskTable(tableModels[i], commonColumnModel);
            }

            currentTable.setFocusable(false);
            currentTable.setRowSelectionAllowed(false);
            
            JLabel titleLabel = new JLabel(titles.get(i));
            titleLabel.setVisible(isTableTitleVisible);

            displayAreaPanel.add(titleLabel);
            
            if (commonColumnModel == null) {
                commonColumnModel = currentTable.getColumnModel();
                displayAreaPanel.add(currentTable.getTableHeader());
            }

            displayAreaPanel.add(currentTable);
            displayAreaPanel.add(createInvisibleJPanel(INVISIBLE_JPANEL_WIDTH,
                    INVISIBLE_JPANEL_HEIGHT));
        }

        displayAreaPanel.revalidate();
        displayAreaPanel.repaint();

        return true;
    }

    private JPanel createInvisibleJPanel(int width, int height) {
        JPanel invisiblePanel = new JPanel();
        invisiblePanel.setSize(new Dimension(width, height));
        invisiblePanel.setOpaque(false);
        return invisiblePanel;
    }

    private JTextArea createJTextAreaWithMonospaceFont() {
        JTextArea textArea = new JTextArea();
        textArea.setFont(new Font(DISPLAY_AREA_FONT_NAME, DISPLAY_AREA_FONT_STYLE,
                DISPLAY_AREA_FONT_SIZE));
        return textArea;
    }
    

    @Override
    public boolean showTasks(List<Task> tasks, DisplayType displayType, List<String> titles) {

        int minTable = -1;
        int minRowCountPerTable = -1;
        if (displayType == DisplayType.DEFAULT) {
            minTable = DEFAULT_DISPLAY_MIN_TABLE;
            minRowCountPerTable = DEFAULT_DISPLAY_MIN_ROW;
        } else if (displayType == DisplayType.FILTERED) {
            minTable = FILTERED_DISPLAY_MIN_TABLE;
            minRowCountPerTable = FILTERED_DISPLAY_MIN_ROW;
        } else {
            assert false : "DisplayType = ?";
        }

        Object[][][] taskListsData = FormatterHelper.getTaskListData(tasks,
                displayType == DisplayType.DEFAULT, minTable, minRowCountPerTable);
        assert taskListsData != null;

        TaskTableModel[] tableModels = new TaskTableModel[taskListsData.length];

        for (int taskListIndex = 0; taskListIndex < taskListsData.length; taskListIndex++) {
            Object[][] currentTaskListData = taskListsData[taskListIndex];
            tableModels[taskListIndex] = new TaskTableModel(currentTaskListData);
        }

        if (displayType == DisplayType.FILTERED) {
            return showToUserFilteredTable(tableModels, titles);
        } else {
            return showToUserDefaultTable(tableModels, titles);
        }
    }
    
    @Override
    public boolean showStatusToUser(String stringToShow) {
        logger.info("Entering showStatusToUser(stringToShow=" + stringToShow + ")");
        
        statusBar.setText(stringToShow);
        
        logger.info("Returning from showStatusToUser");
        
        return true;
    }
}
```
###### Tasky/src/ui/StatusBar.java
``` java
/**
 * This class implements a StatusBar-like widget using <code>Swing</code>
 */
@SuppressWarnings("serial")
public class StatusBar extends JPanel {
    
    private Logger logger = Logger.getGlobal();
    private static final Color THEME_COLOR = new Color(0x443266);
    private static final String DEFAULT_STATUS_BAR_TEXT = "Tasky is ready.";
    private JLabel statusLabel;
    
    public StatusBar() {
        super(new FlowLayout(FlowLayout.LEFT));
        initializeLabel();
        initializeStatusBar();
    }

    private void initializeStatusBar() {
        setBorder(new BevelBorder(BevelBorder.LOWERED));
        add(statusLabel);
        setPreferredSize(getPreferredSize());
    }

    private void initializeLabel() {
        statusLabel = new JLabel(DEFAULT_STATUS_BAR_TEXT);
        statusLabel.setHorizontalAlignment(SwingConstants.LEFT);
        statusLabel.setFont(new Font(statusLabel.getFont().getName(), Font.PLAIN, 11));
        statusLabel.setForeground(THEME_COLOR);
    }
    
    public void setText(String text) {
        logger.info("Entering setText(text=" + text + ")");
        
        statusLabel.setText(text);
        
        logger.info("Returning from setText");
    }
    
}
```
###### Tasky/src/ui/tasktable/TaskTableModel.java
``` java
    /**
     * Initialize TaskTableModel with 2D object array taskListData where the first dimension
     * is an array of tasks data, and the second dimension describes each field of the task.
     * Each element of taskListData is still a raw object based on the corresponding field in
     * the <code>Task</code> class. The constructor will then format the data as string so that
     * it can be displayed in the table.
     * @param taskListData 2D object array containing tasks data.
     */
    public TaskTableModel(Object[][] taskListData) {
        super();

        assert taskListData != null;

        Pair<Object[][], Boolean[]> formattedData = formatter.formatTaskList(taskListData);
        data = formattedData.getFirst();
        isDone = formattedData.getSecond();
    }
    
```
###### Tasky/src/ui/tasktable/TaskTableModel.java
``` java
    @Override
    public String getColumnName(int column) {
        return columnNames[column];
    }
    
```
###### Tasky/src/ui/tasktable/TaskTableModel.java
``` java
    @Override
    public int getRowCount() {
        return data.length;
    }

```
###### Tasky/src/ui/tasktable/TaskTableModel.java
``` java
    @Override
    public int getColumnCount() {
        return columnNames.length;
    }

```
###### Tasky/src/ui/tasktable/TaskTableModel.java
``` java
    @Override
    public Object getValueAt(int rowIndex, int columnIndex) {
        return data[rowIndex][columnIndex];
    }
    
```
###### Tasky/src/ui/tasktable/TaskTableModel.java
``` java
    /**
     * Returns whether task at particular index has been done or not.
     * @param taskIndex Task index
     * @return            whether the task has been done or not.
     */
    public boolean isTaskDone(int taskIndex) {
        return isDone[taskIndex] != null ? isDone[taskIndex] : false;
    }

}
```
###### Tasky/src/ui/TaskTable.java
``` java
    public TaskTable(TaskTableModel dm) {
        super(dm);
        setBorder(new LineBorder(Color.LIGHT_GRAY));
        
        assert COLUMN_ALIGNMENTS.length == FormatterHelper.COLUMN_COUNT;
        assert SET_MAX_WIDTH.length == FormatterHelper.COLUMN_COUNT;

        this.model = dm;
        
        prepareTable();
    }
    
```
###### Tasky/src/ui/TaskTable.java
``` java
    public TaskTable(TaskTableModel dm, TableColumnModel cm) {
        super(dm, cm);
        setBorder(new LineBorder(Color.LIGHT_GRAY));
        
        assert COLUMN_ALIGNMENTS.length == FormatterHelper.COLUMN_COUNT;
        assert SET_MAX_WIDTH.length == FormatterHelper.COLUMN_COUNT;

        this.model = dm;
        
        prepareTable();
    }
    
```
###### Tasky/src/ui/TaskTable.java
``` java
    private void prepareTable() {
        prepareTableHeader();
        prepareTableAlignment();
        prepareTableGrid();
        
        //fixColumnHeight();
        fixColumnWidth();
    }
    
```
###### Tasky/src/ui/TaskTable.java
``` java
    private void fixColumnWidth() {
        TableColumnModel columnModel = getColumnModel();
        int columnCount = columnModel.getColumnCount();
        
        for (int i = 0; i < columnCount; i++) {
            int columnWidth = getColumnWidth(i);
            setColumnWidth(i, columnWidth);
        }
    }
    
```
###### Tasky/src/ui/TaskTable.java
``` java
    private void setColumnWidth(int columnIndex, int columnWidth) {
        //columnWidth = 300;
        TableColumn tableColumn = getColumnModel().getColumn(columnIndex);
        tableColumn.setPreferredWidth(columnWidth);
        if (SET_MAX_WIDTH[columnIndex]) {
            tableColumn.setMaxWidth(columnWidth);
        }
    }
    
```
###### Tasky/src/ui/TaskTable.java
``` java
    private int getColumnWidth(int columnIndex) {
        int headerWidth = getHeaderWidth(columnIndex);
        int contentWidth = getContentWidth(columnIndex);
        int resultingWidth = Math.max(headerWidth, contentWidth);
        
        return resultingWidth;
    }
    
```
###### Tasky/src/ui/TaskTable.java
``` java
    private int getContentWidth(int columnIndex) {
        int rowCount = getRowCount();
        
        int maxContentWidth = 0;
        for (int i = 0; i < rowCount; i++) {
            TableCellRenderer tableCellRenderer = getCellRenderer(i, columnIndex);
            Component component = prepareRenderer(tableCellRenderer, i, columnIndex);
            
            int cellPreferredWidth = component.getPreferredSize().width + getIntercellSpacing().width;
            
            maxContentWidth = Math.max(maxContentWidth, cellPreferredWidth);
        }
        
        return maxContentWidth;
    }
    
```
###### Tasky/src/ui/TaskTable.java
``` java
    private int getHeaderWidth(int columnIndex) {
        TableColumn tableColumn = getColumnModel().getColumn(columnIndex);
        TableCellRenderer renderer = tableColumn.getHeaderRenderer();
        if (renderer == null) {
            renderer = getTableHeader().getDefaultRenderer();
        }
        
        Component component = renderer.getTableCellRendererComponent(this,
                tableColumn.getHeaderValue(), false, false, -1, columnIndex);
        
        return component.getPreferredSize().width;
    }
    
```
###### Tasky/src/ui/TaskTable.java
``` java
    private void prepareTableHeader() {
        JTableHeader tableHeader = getTableHeader();
        tableHeader.setFont(new Font(HEADER_FONT_NAME, HEADER_FONT_STYLE, HEADER_FONT_SIZE));
        tableHeader.setBackground(HEADER_COLOR);
        tableHeader.setForeground(Color.WHITE);
        
    }
    
```
###### Tasky/src/ui/TaskTable.java
``` java
    private void prepareTableGrid() {
        setShowGrid(true);
        setGridColor(Color.LIGHT_GRAY);
    }
    
```
###### Tasky/src/ui/TaskTable.java
``` java
    private void prepareTableAlignment() {
        prepareHeaderAlignment();
        prepareContentAlignment();
    }
    
```
###### Tasky/src/ui/TaskTable.java
``` java
    private void prepareContentAlignment() {
        TableColumnModel tableColumnModel = getColumnModel();
        int columnCount = tableColumnModel.getColumnCount();
        
        for (int i = 0; i < columnCount; i++) {
            TableColumn currentTableColumn = tableColumnModel.getColumn(i);
            
            DefaultTableCellRenderer renderer = new DefaultTableCellRenderer();
            renderer.setHorizontalAlignment(COLUMN_ALIGNMENTS[i]);
            
            currentTableColumn.setCellRenderer(renderer);
        }
    }
    
```
###### Tasky/src/ui/TaskTable.java
``` java
    private void prepareHeaderAlignment() {
        TableCellRenderer headerRenderer = tableHeader.getDefaultRenderer();
        JLabel headerLabel = (JLabel) headerRenderer;
        headerLabel.setHorizontalAlignment(SwingConstants.CENTER);
    }
    
```
###### Tasky/src/ui/TaskTable.java
``` java
    @Override
    public Component prepareRenderer(TableCellRenderer renderer, int row, int column) {
        Component c = super.prepareRenderer(renderer, row, column);
        giveColour(c, row, column);
        return c;
    }
    
```
###### Tasky/src/ui/TaskTable.java
``` java
    private void giveColour(Component c, int row, int column) {
        if (row % 2 == 0) {
            c.setBackground(DEFAULT_ROW_COLOR);
        } else {
            c.setBackground(ALTERNATE_ROW_COLOR);
        }
        
        //If the task is done, make it green
        if (model.isTaskDone(row)) {
            c.setBackground(DONE_COLOR);
        }
    }
}
```
###### Tasky/src/ui/TextUI.java
``` java
/**
 * This class implements UI. This class mainly uses console to display data to and 
 * interact with the user.
 */
public class TextUI implements UI {
    
    /*
     * Assume standard console height + a few more
     */
    private static final int MAX_CONSOLE_LINE = 35;
    
    private TextFormatter taskListFormatter = new TextFormatter();
    private Scanner userInputScanner = new Scanner(System.in);
    
    private String currentTaskData = "";
    private String currentStatus = "";
    
    @Override
    public boolean showToUser(String stringToShow) {
        System.out.println(stringToShow);
        return true;
    }
    
    private boolean refreshConsole() {
        clearConsole();
        outputNewData();
        return true;
    }

    private void outputNewData() {
        System.out.println(currentTaskData);
        System.out.println(currentStatus);
    }

    @Override
    public boolean showStatusToUser(String stringToShow) {
        setNewStatus(stringToShow);
        return refreshConsole();
    }

    private void setNewStatus(String stringToShow) {
        currentStatus = stringToShow;
    }

    @Override
    public boolean showTasks(List<Task> tasks, DisplayType displayType, List<String> titles) {
        int minTable = -1;
        int minRowCountPerTable = -1;
        if (displayType == DisplayType.DEFAULT) {
            minTable = DEFAULT_DISPLAY_MIN_TABLE;
            minRowCountPerTable = DEFAULT_DISPLAY_MIN_ROW;
        } else if (displayType == DisplayType.FILTERED) {
            minTable = FILTERED_DISPLAY_MIN_TABLE;
            minRowCountPerTable = FILTERED_DISPLAY_MIN_ROW;
        } else {
            assert false : "DisplayType = ?";
        }

        Object[][][] taskListsData = FormatterHelper.getTaskListData(tasks,
                displayType == DisplayType.DEFAULT, minTable, minRowCountPerTable);
        assert taskListsData != null;

        String formattedTaskList = taskListFormatter.formatTaskList(taskListsData,
                titles, MAXIMUM_COLUMN_WIDTH);
        
        setNewTaskData(formattedTaskList);
        return refreshConsole();
    }

    private void setNewTaskData(String formattedTaskList) {
        currentTaskData = formattedTaskList;
    }

    private void clearConsole() {
        for (int i = 0; i < MAX_CONSOLE_LINE; i++) {
            System.out.println();
        }
    }

    @Override
    public String promptUser(String prompt) {
        System.out.print(prompt);
        String userInput = readUserInput();
        return userInput;
    }

    private String readUserInput() {
        String userInput = userInputScanner.nextLine();
        return userInput;
    }

}
```
###### Tasky/src/ui/UI.java
``` java
/**
 * This class serves as interface for GraphicalUI and TextUI
 */
public interface UI {

    public enum DisplayType {
        DEFAULT, FILTERED
    }
    
    static final String DEFAULT_PROMPT = "command ";
    static final String DISPLAY_AREA_FONT_NAME = "Lucida Console";
    
    static final int MAXIMUM_COLUMN_WIDTH = 30;
    
    static final int DEFAULT_DISPLAY_MIN_TABLE = 3;
    static final int DEFAULT_DISPLAY_MIN_ROW = 3;
    static final int FILTERED_DISPLAY_MIN_ROW = 1;
    static final int FILTERED_DISPLAY_MIN_TABLE = 1;
    
    /**
     * Asks the UI to display content to user
     * @param stringToShow
     * @return true if successful
     */
    public boolean showToUser(String stringToShow);
    
    /**
     * Asks the UI to display content to user in the status bar
     * @param stringToShow
     * @return true if successful
     */
    public boolean showStatusToUser(String stringToShow);
    
    /**
     * Asks the UI to display the list of tasks
     * @param tasks
     * @return true if successful
     */
    public boolean showTasks(List<Task> tasks, DisplayType displayType, List<String> titles);
    
    /**
     * Prompt message and obtain user input
     * @param prompt message to prompt user
     * @return input from user
     */
    public String promptUser(String prompt);
}
```
###### Tasky/src/ui/UserInputHistory.java
``` java
/**
 * This class is a data structure used to store user commands and also
 * enable the user to access them.
 */
public class UserInputHistory {
    
    private static final String EMPTY_STRING = "";
    
    private List<String> userInputs = new ArrayList<>();
    private int position = 0;
    
    /**
     * Add user input to user input history list.
     * @param userInput
     */
    public void addToHistory(String userInput) {
        userInputs.add(userInput);
        position = userInputs.size();
    }
    
    /**
     * Move the pointer in user input history list to the older
     * one. If the pointer is already pointing to the oldest one,
     * nothing happens to the pointer.
     * @return user input referred by the pointer
     */
    public String moveUpInHistory() {
        if (position > 0) {
            position--;
        }
        return getPosition(position);
    }
    
    /**
     * Move the pointer in user input history list to the more
     * recent one. If the pointer is already pointing to the most
     * recent one, nothing happens to the pointer.
     * @return user input referred by the pointer
     */
    public String moveDownInHistory() {
        if (position + 1 <= userInputs.size()) {
            position++;
        }
        return getPosition(position);
    }
    
    /**
     * Get user input at position according to the parameter
     * If position is equal to the size of userInput that is
     * already recorded, it returns empty string
     * @param position
     * @return user input at the requested position
     */
    public String getPosition(int position) {
        if (position < 0 || position > userInputs.size()) {
            throw new IndexOutOfBoundsException();
        }

        if (position == userInputs.size()) {
            return EMPTY_STRING;
        } else {
            return userInputs.get(position);
        }
    }
}
```
###### Tasky/src/ui/VerticalLayout.java
``` java
/**
 * This class serves as the main layout for GraphicalUI<br>
 * @see ui.GraphicalUI
 */
@SuppressWarnings("serial")
public class VerticalLayout extends GridBagLayout {
    
    private static final double COMPONENT_WEIGHT_X = 1.0;
    private static final double COMPONENT_WEIGHT_Y = 1.0;
    private static final double NEUTRAL_WEIGHT = 0.0;
    private static final int COMPONENT_POS_X = 0;
    private static final int COMPONENT_GRID_HEIGHT = 1;
    private static final int COMPONENT_GRID_WIDTH = 1;
    private static final int COMPONENT_FILL = GridBagConstraints.BOTH;

    private int componentCount = 0;
    private Component lastComponent = null;
    private GridBagConstraints lastComponentConstraint = null;
    
    public VerticalLayout() {
        super();
    }
    
    @Override
    public void addLayoutComponent(Component comp, Object constraint) {
        assert comp != null : "Cannot add null Component";
        assert constraint == null ||
                constraint instanceof Insets : "Can only accept Insets as constraint";
        
        resetLastComponentWeightY();
        
        GridBagConstraints newComponentConstraint = new GridBagConstraints();
        newComponentConstraint.weightx = COMPONENT_WEIGHT_X;
        newComponentConstraint.weighty = COMPONENT_WEIGHT_Y;
        newComponentConstraint.gridy = componentCount;
        newComponentConstraint.gridx = COMPONENT_POS_X;
        newComponentConstraint.gridheight = COMPONENT_GRID_HEIGHT;
        newComponentConstraint.gridwidth = COMPONENT_GRID_WIDTH;
        newComponentConstraint.fill = COMPONENT_FILL;
        if (constraint != null) {
            newComponentConstraint.insets = (Insets) constraint;
        }
        
        super.addLayoutComponent(comp, newComponentConstraint);
        componentCount++;
        lastComponent = comp;
        lastComponentConstraint = newComponentConstraint;
    }
    
    private void resetLastComponentWeightY() {
        if (lastComponent != null) {
            lastComponentConstraint.weighty = NEUTRAL_WEIGHT;
            super.setConstraints(lastComponent, lastComponentConstraint);
        }
    }
    
    public void resetLayout() {
        componentCount = 0;
        lastComponent = null;
    }
}
```
